#!/usr/bin/perl -Tw
#
# W3C HTML Validation Service
# A CGI script to retrieve and validate an HTML file
#
# Copyright 1995-2001 Gerald Oskoboiny <gerald@w3.org>
# for additional contributors, see http://dev.w3.org/cvsweb/validator/
#
# This source code is available under the license at:
#     http://www.w3.org/Consortium/Legal/copyright-software
#
# $Id: check,v 1.200.2.18 2002-04-04 17:04:37 link Exp $

#
# Disable buffering on STDOUT!
$| = 1;

#
# We need Perl 5.004.
require 5.004;

###############################################################################
#### Load modules. ############################################################
###############################################################################

use strict;
use LWP::UserAgent;
use URI;
use URI::Escape;
use CGI::Carp;
use CGI qw(:cgi -newstyle_urls -private_tempfiles);
use Text::Wrap;
use IPC::Open3;
use IO::File;
use Text::Iconv; # on debian: apt-get install libtext-iconv-perl
use HTML::Parser 3.25; # Need 3.25 for $p->ignore_elements.


###############################################################################
#### Constant definitions. ####################################################
###############################################################################

#
# Define global constants
use constant TRUE  => 1;
use constant FALSE => 0;

#
# Tentative Validation Severeties.
use constant T_DEBUG =>  1; # 0000 0001
use constant T_INFO  =>  2; # 0000 0010
use constant T_WARN  =>  4; # 0000 0100
use constant T_ERROR =>  8; # 0000 1000
use constant T_FATAL => 16; # 0001 0000

use constant T_CHARSET_KLUDGE => 128; # 1000 0000


#
# Define global variables.
use vars qw($DEBUG $CFG $VERSION);

#
# Read Config Files.
$CFG = &read_cfg($ENV{W3C_VALIDATOR_CFG} || '/etc/w3c/validator.conf');

#
# Set debug flag.
$DEBUG = TRUE if $ENV{W3C_VALIDATOR_DEBUG} || $CFG->{DEBUG};

#
# Strings
$VERSION    =  q$Revision: 1.200.2.18 $;
$VERSION    =~ s/Revision: ([\d\.]+) /$1/;

#
# Get rid of (possibly insecure) $PATH.
delete $ENV{PATH};


###############################################################################
#### Process CGI variables and initialize. ####################################
###############################################################################

#
# Create a new CGI object.
my $q = new CGI;

#
# The data structure that will hold all session data.
my $File;

#
# Pseudo-SSI include header and footer for output.
$File->{'Header'} = &prepSSI({
			      File     => $CFG->{'Header'},
			      Title    => 'Validation Results',
			      Revision => $VERSION,
			     });
$File->{'Footer'} = &prepSSI({
			      File => $CFG->{'Footer'},
			      Date => q$Date: 2002-04-04 17:04:37 $,
			     });

#
# SSI Footer for static pages does not include closing tags for body & html.
$File->{'Footer'} .= qq(  </body>\n</html>\n);

#
# Prepare standard HTML preamble for output.
$File->{'Results'}  = "Content-Language: en\n";
$File->{'Results'} .= "Content-Type: text/html; charset=utf-8\n\n";
$File->{'Results'} .= $File->{'Header'};


##############################################
# Populate $File->{Env} -- Session Metadata. #
##############################################

#
# The URL to this CGI Script.
$File->{Env}->{'Self URI'} = $q->url(-query => 0);

#
# Initialize parameters we'll need (and override) later.
$File->{Charset}->{HTTP} = ''; # Set to "ISO-8859-1" to use HTTP defaulting rules.
$File->{Charset}->{META} = '';
$File->{Charset}->{XML}  = '';
$File->{Charset}->{Use}  = ''; # The charset used for validation.


#########################################
# Populate $File->{Opt} -- CGI Options. #
#########################################

#
# Preprocess the CGI parameters.
$q = &prepCGI($File, $q);

#
# Set session switches.
$File->{Opt}->{'Outline'}        = $q->param('outline') ? TRUE                 : FALSE;
$File->{Opt}->{'Show Source'}    = $q->param('ss')      ? TRUE                 : FALSE;
$File->{Opt}->{'Show Parsetree'} = $q->param('sp')      ? TRUE                 : FALSE;
$File->{Opt}->{'No Attributes'}  = $q->param('noatt')   ? TRUE                 : FALSE;
$File->{Opt}->{'Show ESIS'}      = $q->param('esis')    ? TRUE                 : FALSE;
$File->{Opt}->{'Show Errors'}    = $q->param('errors')  ? TRUE                 : FALSE;
$File->{Opt}->{'Charset'}        = $q->param('charset') ? $q->param('charset') :    '';
$File->{Opt}->{'DOCTYPE'}        = $q->param('doctype') ? $q->param('doctype') :    '';
$File->{Opt}->{'URI'}            = $q->param('uri')     ? $q->param('uri')     :    '';


#
# Get the file and metadata.
if ($q->param('uploaded_file')) {
  $File = &handle_file($q, $File);
} elsif ($q->param('fragment')) {
  $File = &handle_frag($q, $File);
} elsif ($q->param('uri')) {
  my $rejected = &uri_rejected($File);
  if ($rejected) {
    $File->{'Error Flagged'} = TRUE;
    $File->{'Error Message'} = $rejected;
  } else {
    $File = &handle_uri($q, $File);
  }
}

#
# Get rid of the CGI object.
undef $q;

#
# We don't need STDIN any more, so get rid of it to avoid getting clobbered
# by Apache::Registry's idiotic interference under mod_perl.
untie *STDIN;


###############################################################################
#### Output validation results. ###############################################
###############################################################################

#
# Abort if an error was flagged during initialization.
if ($File->{'Error Flagged'}) {
  print $File->{'Results'};
  print $File->{'Error Message'};
  print $File->{'Footer'};
  undef $File;
  exit;
}


#
# Overall parsing algorithm for documents returned as text/html:
#
# For documents that come to us as text/html,
#
#  1. check if there's a doctype
#  2. if there is a doctype, parse/validate against that DTD
#  3. if no doctype, check for an xmlns= attribute on the first element
#  4. if there is an xmlns= attribute, check for XML well-formedness
#  5. if there is no xmlns= attribute, and no DOCTYPE, punt.
#

#
# Detect and remove a UTF-8 BOM.
$File->{Content}[0] =~ s/^\xEF\xBB\xBF//
  and &add_warning($File, <<".EOF.");
     <em>Note:</em> UTF-8 'BOM' detected and removed. (This message is
     informational. See the
     <a href="$CFG->{'Msg FAQ URI'}#utf8-bom">explanation</a> for details.)
.EOF.


#
# Override DOCTYPE if user asked for it.
if ($File->{Opt}->{DOCTYPE}
    and not $File->{Opt}->{DOCTYPE} =~ /(Inline|detect)/i) {
  $File->{Content} = &supress_doctype($File->{Content});
  unshift @{$File->{Content}}, $CFG->{'Doctypes'}->{$File->{Opt}->{DOCTYPE}};
  my $dtd = ent($File->{Opt}->{DOCTYPE});
  &add_warning($File, <<".EOF.");
  <strong>DOCTYPE Override in effect!</strong> Any DOCTYPE Declaration in the
  document has been supressed and the DOCTYPE for &#171;<code>$dtd</code>&#187;
  inserted instead. The document will not be Valid until you alter the source
  file to reflect this new DOCTYPE.
.EOF.
  $File->{Tentative} |= T_ERROR; # Tag it as Invalid.
}

#
# Try to extract a DOCTYPE or xmlns.
$File = &preparse($File);


#
# Set document type to XHTML if the DOCTYPE was for XHTML.
# Set document type to MathML if the DOCTYPE was for MathML.
# This happens when the file is served as text/html
$File->{Type} = 'xhtml+xml'  if $File->{DOCTYPE} =~ /xhtml/i;
$File->{Type} = 'mathml+xml' if $File->{DOCTYPE} =~ /mathml/i;


#
# Figure out which charset was detected.
$File->{Charset}->{Use} = $File->{Charset}->{HTTP} if $File->{Charset}->{HTTP};
$File->{Charset}->{Use} = $File->{Charset}->{META} if $File->{Charset}->{META};
$File->{Charset}->{Use} = $File->{Charset}->{XML}  if $File->{Charset}->{XML};


#
# Sanity check Chrset information and add any warnings necessary.
$File = &validate_charset($File);


#
# Print different things if we got redirected or had a file upload.
if ($File->{'Is Upload'}) {
  &add_table($File, "File", $File->{URI});
} else {
  my $size = (length($File->{Opt}->{URI}) || 38) + 2;
  $size = 70 if $size > 70;

  if (URI::eq("$File->{Opt}->{URI}", $File->{URI})) {
    &add_table($File, qq(<label title="Address of Page to Validate" for="uri">Address</label>),
	       '<input type="text" id="uri" name="uri" size="' . $size
	       . '" value="' . $File->{Opt}->{URI} . '" />');
  } else {
    &add_table($File, qq(<label title="Address of Page to Validate" for="uri">URI</label>),
	       '<input type="text" id="uri" name="uri" size="' . $size
	       . '" value="' . $File->{URI} . '" />');
    &add_warning($File, '<em>Note:</em> The URI you gave me, &#171;<code>' .
		 $File->{Opt}->{URI} . '</code>&#187;, ' .
		 'returned a redirect to ' .
		 '&#171;<code>' . $File->{URI} . '</code>&#187;.');
  }
}


&add_table($File, "Modified", $File->{Modified})  if $File->{Modified};
&add_table($File, "Server", $File->{Server})  if $File->{Server};
&add_table($File, "Size", $File->{Size})  if $File->{Size};
unless ($File->{Opt}->{'Is Upload'}) {
  &add_table($File,
	     qq(<label title="Character Encoding" for="charset">Encoding</label>),
	     $File->{Charset}->{Use} . ' ' .
	     &CGI::popup_menu(-name => 'charset', -id => 'charset',
			    -values => [
					'(detect automatically)',
					'utf-8 (Unicode, worldwide)',
					'iso-8859-1 (Western Europe)',
					'iso-8859-2 (Central Europe)',
					'iso-8859-3 (Maltese)',
					'iso-8859-4 (Baltic Rim)',
					'iso-8859-5 (Cyrillic)',
					'iso-8859-6-i (Arabic)',
					'iso-8859-7 (Greek)',
					'iso-8859-8-i (Hebrew)',
					'iso-8859-9 (Turkish)',
					'iso-8859-10 (Latin 6)',
					'iso-8859-13 (Latin 7)',
					'iso-8859-14 (Celtic)',
					'iso-8859-15 (Latin 9)',
					'us-ascii (basic English)',
					'euc-jp (Japanese, Unix)',
					'shift_jis (Japanese, Win/Mac)',
					'iso-2022-jp (Japanese, email)',
					'euc-kr (Korean)',
					'gb2312 (Chinese, simplified)',
					'big5 (Chinese, traditional)',
					'tis-620 (Thai)',
					'koi8-r (Russian)',
					'koi8-u (Ukrainian)',
					'macintosh (MacRoman)',
					'windows-1250 (Central Europe)',
					'windows-1251 (Cyrillic)',
					'windows-1252 (Western Europe)',
					'windows-1253 (Greek)',
					'windows-1254 (Turkish)',
					'windows-1255 (Hebrew)',
					'windows-1256 (Arabic)',
					'windows-1257 (Baltic Rim)',
				       ],
			   )
	    );
}


#
# Check Encoding and transliterate.
$File = &validate_encoding($File);

#
# Abort if an error was flagged during Encoding Validation.
if ($File->{'Error Flagged'}) {
  print $File->{'Results'};
  print $File->{'Error Message'};
  print $File->{'Footer'};
  undef $File;
  exit;
}



#
# Default XML/SGML Catalog and XML Flags for SP.
my $catalog  = qq($CFG->{'SGML Library'}/xml.soc);
my @xmlflags = '-wxml';


#
# Defaults for SP; turn off fixed charset mode and enable XML semantics for
# detecting the input charset. Only way to set this is through %ENV.
$ENV{SP_CHARSET_FIXED} = 'NO';
$ENV{SP_ENCODING}      = 'XML';

#
# Generic XML with Root Namespace.
if (&is_xml($File->{Type}) or $File->{Namespace}) {
  push(@xmlflags, '-wno-valid') unless $File->{DOCTYPE};
}

#
# SVG and SMIL.
$catalog = qq($CFG->{'SGML Library'}/svg.soc)    if &is_svg($File->{Type});
$catalog = qq($CFG->{'SGML Library'}/smil.soc)   if &is_smil($File->{Type});

#
# HTML. Turn back to SGML semantics.
if (&is_html($File->{Type})) {
  $ENV{SP_CHARSET_FIXED} = 'YES';
  $ENV{SP_ENCODING}      = 'UTF-8';
  $catalog  = qq($CFG->{'SGML Library'}/catalog);
  @xmlflags = '-wnon-sgml-char-ref';
}

#
# MathML and XHTML. Must be here because they're usually serverd as text/html
# to deal with braindead browsers. IOW, these override the check for &is_html.
$catalog = qq($CFG->{'SGML Library'}/xhtml.soc)  if &is_xhtml($File->{Type});
$catalog = qq($CFG->{'SGML Library'}/mathml.soc) if &is_mathml($File->{Type});


my @cmd = ($CFG->{'SGML Parser'}, '-c', $catalog, '-E0', @xmlflags);
&add_table($File, 'Command', "<code>@cmd</code>") if $DEBUG;

#
# Temporary filehandles.
my $spin  = IO::File->new_tmpfile;
my $spout = IO::File->new_tmpfile;
my $sperr = IO::File->new_tmpfile;

#
# Dump file to a temp file for parsing.
for (@{$File->{Content}}) {
  print $spin $_, "\n";
}

#
# seek() to beginning of the file.
seek $spin, 0, 0;

#
# Run it through SP, redirecting output to temporary files.
my $pid = do {
  local(*SPIN, *SPOUT, *SPERR)  = ($spin, $spout, $sperr);
  open3("<&SPIN", ">&SPOUT", ">&SPERR", @cmd);
};


#
# Close input file, reap the kid, and rewind temporary filehandles.
close $spin;
waitpid $pid, 0;
seek $_, 0, 0 for $spout, $sperr;

$File = &parse_errors($File, $sperr); # Parse error output.

$File->{ESIS} = [];
my $elements_found = 0;
while (<$spout>) {
  push @{$File->{'DEBUG'}->{ESIS}}, $_;
  $elements_found++ if /^\(/;

  if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml') {
    if (/^Axmlns() \w+ (.*)/ or /^Axmlns:([^ ]+) \w+ (.*)/) {
      if (not $File->{Namespace} and $elements_found == 0 and $1 eq "") {
	$File->{Namespace} = $2;
      }
      $File->{Namespaces}->{$2}++;
    }
  }
  next if / IMPLIED$/;
  next if /^ASDAFORM CDATA /;
  next if /^ASDAPREF CDATA /;
  chomp; # Removes trailing newlines
  push @{$File->{ESIS}}, $_;
}
undef $spout;

if ($File->{ESIS}->[-1] =~ /^C$/) {
  undef $File->{ESIS}->[-1];
  $File->{'Is Valid'} = TRUE;
} else {
  $File->{'Is Valid'} = FALSE;
}


#
# Set Version to be the FPI initially.
$File->{Version} = $File->{DOCTYPE};

#
# Extract any version attribute from the ESIS.
for (@{$File->{ESIS}}) {
  next unless /^AVERSION CDATA (.*)/;
  $File->{Version} = $1;
  last;
}

#
# Force "XML" if type is an XML type and an FPI was not found.
# Otherwise set the type to be the FPI.
if (&is_xml($File->{Type}) and not $File->{DOCTYPE}) {
  $File->{Version} = 'XML';
} else {
  $File->{Version} = $File->{DOCTYPE} unless $File->{Version};
}


#$File->{Version} = $File->{DOCTYPE} if &is_xhtml($File->{Type});
#$File->{Version} = $File->{DOCTYPE} if &is_mathml($File->{Type});
#$File->{Version} = $File->{DOCTYPE} if &is_svg($File->{Type});
#$File->{Version} = $File->{DOCTYPE} if &is_smil($File->{Type});

#
# Get the pretty text version of the FPI if a mapping exists.
$File->{Version} = $CFG->{'FPI to Text'}->{$File->{Version}} || $File->{Version};



&add_table($File, qq(<label for="doctype">Doctype</label>),
	   $File->{Version} . ' ' .
	   &CGI::popup_menu(
			    -name => 'doctype',
			    -id => 'doctype',
			    -values => [
					'(detect automatically)',
					'XHTML 1.0 Strict',
					'XHTML 1.0 Transitional',
					'XHTML 1.0 Frameset',
					'HTML 4.01 Strict',
					'HTML 4.01 Transitional',
					'HTML 4.01 Frameset',
					'HTML 3.2',
					'HTML 2.0',
				       ],
			   )
	  );


if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml') {
  if ($File->{Type} eq 'xhtml' and $File->{Namespace} ne 'http://www.w3.org/1999/xhtml') {
    &add_warning($File, "Unknown namespace (&#171;<code>$File->{Namespace}</code>&#187;) for text/html document!");
    if ($File->{Namespace} ne '') {
      &add_table($File, "Root Namespace",
	qq(<a href="$File->{Namespace}">$File->{Namespace}</a>));
    }
  } elsif ($File->{Type} eq 'svg' and $File->{Namespace} ne 'http://www.w3.org/2000/svg') {
    &add_warning($File, "Unknown namespace (&#171;<code>$File->{Namespace}</code>&#187;) for SVG document!");
    if ($File->{Namespace} ne '') {
      &add_table($File, "Root Namespace",
	qq(<a href="$File->{Namespace}">$File->{Namespace}</a>));
    }
  } else {
    if ($File->{Namespace} ne '') {
      &add_table($File, "Root Namespace",
	qq(<a href="$File->{Namespace}">$File->{Namespace}</a>));
    }
  }

  if (scalar keys %{$File->{Namespaces}} > 1) {
    my $namespaces = "<ul>";
    for (keys %{$File->{Namespaces}}) {
      $namespaces .= qq(\t<li><a href="$_">$_</a></li>\n)
          unless $_ eq $File->{Namespace}; # Don't repeat Root Namespace.
    }
    &add_table($File, "Other Namespaces", $namespaces . "</ul>");
  }
}




#
# Print header.
print $File->{Results};

print qq(<div class="meat">\n);
print qq(<div class="splash">\n);
&print_table($File);
&print_warnings($File);
print qq(</div>\n);

if (defined $File->{Tentative}) {
  my $class = '';
     $class .= ($File->{Tentative} & T_INFO  ? ' info'    :'');
     $class .= ($File->{Tentative} & T_WARN  ? ' warning' :'');
     $class .= ($File->{Tentative} & T_ERROR ? ' error'   :'');
     $class .= ($File->{Tentative} & T_FATAL ? ' fatal'   :'');

  unless ($File->{Tentative} == T_DEBUG) {
    print <<".EOF.";
    <p id="Notice" class="$class">
      Please note that you have chosen one or more options that alter the
      content of the document before validation, or have not provided enough
      information to accurately validate the document. Even if no errors are
      reported below, the document will not be valid until you manually make
      the changes we have performed automatically. Specifically, if you used
      some of the options that override a property of the document (e.g. the
      DOCTYPE or Character Encoding), you must make the same change to the
      source document or the server setup before it can be valid. You will
      also need to insert an appropriate DOCTYPE Declaration or Character
      Encoding (the "charset" parameter for the Content-Type HTTP header) if
      any of those are missing.
    </p>
.EOF.
  }
}

if ($File->{'Is Valid'}) {
  &report_valid($File);
} else {
  $File->{Opt}->{'Show Source'} = TRUE;
  &report_errors($File);
}

&outline($File)     if $File->{Opt}->{'Outline'};
&show_source($File) if $File->{Opt}->{'Show Source'};
&parse_tree($File)  if $File->{Opt}->{'Show Parsetree'};
&show_esis($File)   if $File->{Opt}->{'Show ESIS'};
&show_errors($File) if $File->{Opt}->{'Show Errors'};

print qq(</div>\n); # End of "Meat".
print $File->{'Footer'};
undef $File;
exit;


#############################################################################
# Subroutine definitions
#############################################################################

#
# Add info to the metadata table datastructure.
sub add_table {push @{shift->{Table}}, { Head => $_[0], Tail => $_[1]}};

#
# Print the table containing the metadata about the Document Entity.
sub print_table {
  my $File = shift;
  my $tableEntry;
  unless ($File->{'Is Upload'}) {
    add_table($File, '<input type="submit" value="Revalidate" />',
	      qq(\n         <label title="Show Page Source"><input type="checkbox" value="" name="ss") .
	      ($File->{Opt}->{'Show Source'}      ? 'checked="checked"' : '') . " />Show Source</label></td><td>\n" .
	      '         <label title="Show an Outline of the document"><input type="checkbox" value="" name="outline"' .
	      ($File->{Opt}->{'Outline'} ? 'checked="checked"' : '') . " />Outline</label></td></tr><tr><td>\n" .
	      '         <label title="Show Parse Tree"><input type="checkbox" value="" name="sp"' .
	      ($File->{Opt}->{'Show Parsetree'}      ? 'checked="checked"' : '') . " />Parse Tree</label></td><td>\n" .
	      '         <label title="Exclude Attributes from Parse Tree"><input type="checkbox" value="" name="noatt"' .
	      ($File->{Opt}->{'No Attributes'}   ? 'checked="checked"' : '') . " />...no attributes</label>\n"
	     );
  }
  print '  <form method="get" action="/check">' unless $File->{'Is Upload'};
  print qq(<table class="header">\n);
  unless ($File->{'Is Valid'}) {
    &add_table($File, 'Errors', scalar(@{$File->{Errors}}) . ' (approximate)');
  }

  for $tableEntry (@{$File->{Table}}) {
    if ($$tableEntry{Head} =~ m(Revalidate)) {
      print "    <tr>\n";
      print ' ' x 6, qq(<th rowspan="2">), $$tableEntry{Head}, ": </th>\n";
      print ' ' x 6, "<td>", $$tableEntry{Tail}, "      </td>\n";
      print "    </tr>\n";
    } else {
      print "    <tr>\n";
      print ' ' x 6, "<th>", $$tableEntry{Head}, ": </th>\n";
      print ' ' x 6, qq(<td colspan="2">), $$tableEntry{Tail}, "</td>\n";
      print "    </tr>\n";
    }
  }
  print "  </table></form>\n";
}

#
# Add a waring message to the output.
sub add_warning {push @{shift->{Warnings}}, shift};

#
# Print out a list of warnings.
sub print_warnings {
  my $File = shift;
  return unless defined @{$File->{Warnings}};
  print qq(  <ul id="Warnings">\n);
  print qq(    <li>$_</li>\n) for @{$File->{Warnings}};
  print "  </ul>\n";
}

#
# Print HTML explaining why/how to use a DOCTYPE Declaration.
sub output_doctype_spiel {
  print <<"EOF";
    <p>
      You should make the first line of your HTML document a DOCTYPE
      declaration, for example, for a typical <a
      href="http://www.w3.org/TR/html4/">HTML 4.01</a> document:
    </p>

    <pre>
      &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
      &lt;html&gt;
	&lt;head&gt;
	  &lt;title&gt;Title&lt;/title&gt;
	&lt;/head&gt;

	&lt;body&gt;
	  &lt;-- ... body of document ... --&gt;
	&lt;/body&gt;
      &lt;/html&gt;</pre>

EOF
}


#
# Leave a message and then die (use for internal errors only)
sub internal_error {
  my $File = shift;
  my ($dieMessage) = shift;
  print <<"EOF";
    <hr />
    <strong class="error">Internal server error ($dieMessage).</strong>
    Please contact <a href="mailto:$CFG->{Maintainer}">maintainer</a>.
EOF
  print $File->{'Footer'};
  die "$dieMessage\n";
}


#
# Generate HTML for the "Jump to:" links in results.
sub print_jump_links {
  my $File = shift;
  my $text  = '';
  my $count = 0;

  $count++ if $File->{Opt}->{'Show Source'};
  $count++ if $File->{Opt}->{'Show Parsetree'};
  $count++ if $File->{Opt}->{'Outline'};

  if ($count) {
    $text .= qq(  <p class="jumpbar">\n   );
    if ($File->{Opt}->{'Show Source'}) {
      $text .= qq(<a href="#source">Source&nbsp;Listing</a>\n    );
    }
    if ($File->{Opt}->{'Show Parsetree'}) {
      $text .= qq(<a href="#parse">Parse&nbsp;Tree</a>\n  );
    }
    if ($File->{Opt}->{'Outline'}) {
      $text .= qq(<a href="#outline">Outline</a>\n    );
    }
    $text .= qq(</p>\n\n);
  }
  print $text;
}


#
# Proxy authentication requests.
sub authenticate {
  my $File       = shift;
  my $resource   = shift;
  my $authHeader = shift;
  my $realm = $resource;
  $realm =~ s([^\w\d.-]*){}g;
  $authHeader =~ s( realm=([\'\"])?([^\1]+)\1){ realm="$realm-$2"};

    print <<"EOF";
Status: 401 Authorization Required
WWW-Authenticate: $authHeader
Connection: close
Content-Type: text/html; charset=utf-8

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html lang="en" xml:lang="en">
  <head><title>401 Authorization Required</title></head>
  <body>
    <h1>Authorization Required</h1>
    <p>Sorry, I am not authorized to access the specified URI.</p>
    <p>
      The URI you specified, <code><a href="$resource">$resource</a></code>,
      returned a 401 "authorization required" response when I tried
      to download it.
    </p>
    <p>
      You should have been prompted by your browser for a
      username/password pair; if you had supplied this information, I
      would have forwarded it to your server for authorization to
      access the resource. You can use your browser's "reload" function
      to try again, if you wish.
    </p>
    <p>
      Of course, you may not want to trust me with this information,
      which is fine. I can tell you that I don't log it or do
      anything else nasty with it, and you can <a
        href="$CFG->{'Home Page'}source/">download the source for
      this service</a> to see what it does, but you have no guarantee
      that this is actually the code I'm using; you basically have to
      decide whether to trust me or not. :-)
    </p>
    <p>
      You should also be aware that the way we proxy this authentication
      information defeats the normal working of HTTP Authentication.
      If you authenticate to server A, your browser may keep sending
      the authentication information to us every time you validate
      a page, regardless of what server it's on, and we'll happily pass
      that on to the server thereby making it possible for a malicious
      server operator to capture your credentials.
    </p>
    <p>
      Due to the way HTTP Authentication works there is no way we can
      avoid this. We are using some "tricks" to fool your client into
      not sending this information in the first place, but there is no
      guarantee this will work. If security is a conern to you, you
      may wish to avoid validating protected resources or take extra
      precautions to prevent your browser from sending authentication
      information when validating other servers.
    </p>
    <p>
      Also note that you shouldn't use HTTP Basic Authentication for
      anything which really needs to be private, since the password
      goes across the network unencrypted.
    </p>
EOF
}


#
# Complain about unknown HTTP responses.
sub print_unknown_http_error_message {
  my $uri = shift;
  my $code = shift;
  my $message = shift;

  print <<"EOF";
  <p>
    I got the following unexpected response when trying to
    retrieve <code><a href="$uri">$uri</a></code>:
  </p>

  <blockquote>
    <p><code>$code $message</code></p>
  </blockquote>

  <p>
    Please make sure you have entered the URI correctly.
  </p>

EOF
}


#
# Print blurb advocating using the CSS Validator.
sub output_css_validator_blurb {
  my $uri = shift;
  $uri = ent($uri);

  print <<"EOHD";
  <p>
    If you use <a href="http://www.w3.org/Style/CSS/">CSS</a> in your document,
    you should also <a
    href="http://jigsaw.w3.org/css-validator/validator?uri=$uri">check it for
    validity</a> using the W3C <a
    href="http://jigsaw.w3.org/css-validator/">CSS Validation Service</a>.
  </p>
EOHD
}


sub print_tip_of_the_day{
  my @tipAddrs = keys %{$CFG->{'Tips DB'}};
  srand(time());
  my $tipAddr = $tipAddrs[rand scalar @tipAddrs];
  my $tipSlug = $CFG->{'Tips DB'}->{$tipAddr};

  print <<"EOHD";
  <dl class="tip">
    <dt><a href="http://www.w3.org/2001/06tips/">Tip Of The Day</a>:</dt>
    <dd><a href="$tipAddr">$tipSlug</a></dd>
  </dl>
EOHD
}


#
# Read TAB-delimited configuration files. Returns a hash reference.
sub read_cfg {
  my $file = shift;
  my %cfg;

  open CFG, $file or die "open($file) returned: $!\n";

  my $fh = new IO::File $file;
  if (defined $fh) {
    while (<$fh>) {
      next if /^\s*$/;
      next if /^\s*\#/;
      chomp;
      my($k, $v) = split /\t+/, $_;
      $v = '' unless defined $v;
      $v = &read_cfg($v) if $v =~ s(^file://){};
      $cfg{$k} = $v;
    }
    undef $fh;
  } else {
    croak "open($file) returned: $!\n";
  }
  return \%cfg;
}

#
# Fetch an URI and return the content and selected meta-info.
sub handle_uri {
  my $q    = shift; # The CGI object.
  my $File = shift; # The master datastructure.

  my $uri = $q->param('uri'); # The URI to fetch.

  my $ua = new LWP::UserAgent;
  $ua->agent("W3C_Validator/$VERSION " . $ua->agent);
  $ua->parse_head(0);  # Parse the http-equiv stuff ourselves. @@ Why?
  my $req = new HTTP::Request(GET => $uri);

  # If we got a Authorization header, the client is back at it after being
  # prompted for a password so we insert the header as is in the request.
  if($ENV{HTTP_AUTHORIZATION}){
    $req->headers->header(Authorization => $ENV{HTTP_AUTHORIZATION});
  }

  my $res = $ua->request($req);

  unless ($res->code == 200) {
    if ($res->code == 401) {
      &authenticate($File, $res->request->url, $res->www_authenticate);
    } else {
      print $File->{Results};
      &print_unknown_http_error_message($uri, $res->code, $res->message);
    }
    print $File->{'Footer'};
    exit;
  }

  my($type, $charset) = &parse_content_type($File, $res->header('Content-Type'));

  my $lastmod = undef;
  if ( $res->last_modified ) {
    $lastmod = scalar(gmtime($res->last_modified));
  }

  $File->{Content}         = &normalize_newlines($res->content);
  $File->{Type}            = $type;
  $File->{Charset}->{HTTP} = $charset;
  $File->{Modified}        = $lastmod;
  $File->{Server}          = scalar $res->server;
  $File->{Size}            = scalar $res->content_length;
  $File->{URI}             = scalar $res->request->url;
  $File->{'Is Upload'}     = FALSE;

  return $File;

}

#
# Handle uploaded file and return the content and selected meta-info.
sub handle_file {
  my $q    = shift; # The CGI object.
  my $File = shift; # The master datastructure.

  my $f = $q->param('uploaded_file');
  my $h = $q->uploadInfo($f);
  my $file;

  while (not eof $f) {$file .= <$f>};
  my($type, $charset) = &parse_content_type($File, $h->{'Content-Type'});

  $File->{Content}         = &normalize_newlines($file);
  $File->{Type}            = $type;
  $File->{Charset}->{HTTP} = $charset;
  $File->{Modified}        = $h->{'Last-Modified'};
  $File->{Server}          = $h->{'Server'};
  $File->{Size}            = $h->{'Content-Length'};
  $File->{URI}             = $q->param('uploaded_file');
  $File->{'Is Upload'}     = TRUE;

  return $File;
}

#
# Handle uploaded file and return the content and selected meta-info.
sub handle_frag {
  my $q    = shift; # The CGI object.
  my $File = shift; # The master datastructure.

  $File->{Content}     = &normalize_newlines(shift->param('fragment'));
  $File->{Type}        = 'html';
  $File->{Modified}    = '';
  $File->{Server}      = '';
  $File->{Size}        = '';
  $File->{URI}         = 'upload://Form Submission';
  $File->{'Is Upload'} = TRUE;

  return $File;
}


#
# Parse a Content-Type and parameters. Return document type and charset.
sub parse_content_type {
  my $File         = shift;
  my $Content_Type = shift;
  my $charset      = '';
  my $type         = '';

  my($ct, @param) = split /\s*;\s*/, lc $Content_Type;

  $type = $CFG->{'File Type'}->{$ct} || $ct;

  foreach my $param (@param) {
    my($p, $v) = split /\s*=\s*/, $param;
    next unless $p =~ m(charset)i;
    if ($v =~ m/([\'\"]?)(\S+)\1/i) {
      $charset = lc $2;
      last;
    }
  }

  if ($type =~ m(/)) {
    $File->{'Error Flagged'} = TRUE;
    $File->{'Error Message'} = <<"    EOF";
    <p class="error">
      Sorry, I am unable to validate this document because its returned
      content-type was <code>$type</code>, which is not currently supported
      by this service.
    </p>
    EOF
  }

  return $type, $charset;
}


#
# Normalize newline forms (CRLF/CR/LF) to native newline.
sub normalize_newlines {
  my $file = shift;

  $file =~ s(\015\012?|\012){\n}g; # Turn ASCII CRLF into native newline.

  return [split /\n/, $file];
}


#
# Return $_[0] encoded for HTML entities (cribbed from merlyn).
sub ent {
  local $_ = shift;
  s(["<&>"]){'&#' . ord($&) . ';'}ge;
  return $_;
}


#
# Truncate source lines for report.
sub truncate_line {
  my $line = shift;
  my $col  = shift;

  if (length $line > 70) {
    if ($col < 25) {      # Truncate at 70 chars and right side only.
      $line = substr($line, 0, 70) . " ...";
    } elsif ($col > 70) { # Keep rightmost 70 chars; left side only.
      my $diff = $col - 50;
      $line = "... " . substr($line, $diff, 70);
      if (length $line == 70 + 4) {
	$line .= " ...";
      }
      if ($col > $diff) {
	$col -= $diff;
      } else {
	$col -= 70;
      }
    } else { # Truncate both sides; leave more on left, and 30 chars on right.
      if ($col < 35) {
	$line = "... " . substr($line, 0, 60);
      } else {
	$line = "... " . substr($line, $col - 35, 60);
	$col = 35;
      }
      if (length $line == 60 + 4) {$line .= " ..."};
    }
  }

  return $line, $col;
}


#
# Supress any existing DOCTYPE by commenting it out.
sub supress_doctype {
  no strict 'vars';
  my $file = shift;
  local $HTML = '';

  HTML::Parser->new(default_h     => [sub {$HTML .= shift}, 'text'],
		    declaration_h => [sub {$HTML .= '<!-- ' . $_[0] . ' -->'}, 'text']
		   )->parse(join "\n", @{$file});
  return [split /\n/, $HTML];
}


#
# Parse errors reported by SP.
sub parse_errors ($$) {
  my $File = shift;
  my $fh   = shift;

  $File->{Errors} = []; # Initialize to an (empty) anonymous array ref.

  for (<$fh>) {
    push @{$File->{'DEBUG'}->{Errors}}, $_;
    my($err, @errors);
    next if /^<OSFD>0:[0-9]+:[0-9]+:[^A-Z]/;
    next if /numbers exceeding 65535 not supported/;
    next if /URL Redirected to/;

    my(@_err) = split /:/;
    next unless $_err[1] eq '<OSFD>0';
    if ($_err[1] =~ m(^<URL>)) {
      @errors = ($_err[0], join(':', $_err[1], $_err[2]), @_err[3..$#_err]);
    } else {
      @errors = @_err;
    }
    $err->{src}  = $errors[1];
    $err->{line} = $errors[2];
    $err->{char} = $errors[3];
    $err->{type} = $errors[4];
    if (
	   $err->{type} eq 'W'
	or $err->{type} eq 'E'
	or $err->{type} eq 'X'
	or $err->{type} eq 'Q'
       ) {
      $err->{msg}  = $errors[5];
      # get rid of non-BMP related error messages
      # (pretending SP understands characters beyond the BMP)
      if ($errors[5] =~ m/"(\d*)" is not a character number in the document character set/) {
	next if $1 >= 65536 && $1 <= 1114110;
      }
    } else {
      $err->{type} = 'I';
      $err->{msg}  = $errors[4];
    }
    push @{$File->{Errors}}, $err;
  }
  undef $fh;
  return $File;
}

#
# Generate a HTML report of detected errors.
sub report_errors ($) {
  my $File = shift;

  print <<"EOHD";
    <h2 class="invalid">This Page Is <strong>NOT</strong> Valid $File->{Version}!</h2>
EOHD

  if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml' or $File->{Type} eq 'mathml' or $File->{Type} eq 'svg' or $File->{Type} eq 'smil') {
    my $xmlvalid = ($File->{DOCTYPE} ? ' and validity' : '');
    print <<"EOHD";
    <p>
      Below are the results of checking this document for <a
      href="http://www.w3.org/TR/REC-xml#sec-conformance">XML
      well-formedness</a>$xmlvalid.
    </p>
EOHD
  } else {
    print <<"EOHD";
  <p>
    Below are the results of attempting to parse this document with
    an SGML parser.
  </p>
  <ul>
EOHD
  }

  foreach my $err (@{$File->{Errors}}) {

    # An unknown FPI and no SI.
    if (   $err->{msg} =~ m(cannot generate system identifier for entity)
	or $err->{msg} =~ m(unrecognized ({{)?DOCTYPE(}})?)i
        or $err->{msg} =~ m(no document type declaration)i) {
      print <<"    .EOF.";
    <li class="fatal"><strong>Fatal Error: $err->{msg}</strong>
    <p>
      I could not parse this document, because it uses a public identifier that
      is not in my <a href="/sgml-lib/catalog">catalog</a>.
    </p>
    .EOF.
      &output_doctype_spiel;
      print '</li>';
      last;
    }

    # No or unknown FPI and a relative SI.
    if ($err->{msg} =~ m(cannot (open|find))) {
      print <<"    .EOF.";
    <li class="fatal"><strong>Fatal Error: $err->{msg}</strong>
    <p>
      I could not parse this document, because it makes reference to a
      system-specific file instead of using a well-known public identifier to
      specify the type of markup being used.
    </p>
    .EOF.
      &output_doctype_spiel;
      print '</li>';
      last;
    }

    # No DOCTYPE.
    if ($err->{msg} =~ m(prolog can\'t be omitted)) {
      print <<"    .EOF.";
    <li class="fatal"><strong>Fatal Error: No DOCTYPE specified!</strong>
    <p>
      I could not parse this document, because it doesn\'t include a
      DOCTYPE Declaration and the detected document type does not permit this.
    </p>
    .EOF.
      &output_doctype_spiel;
      print '</li>';
      last;
    }


    my($line, $col) = &truncate_line($File->{Content}->[$err->{line}-1], $err->{char});

    # Strip curlies from lq-nsgmls output.
    $err->{msg} =~ s/[{}]//g;

    # Find index into the %frag hash for the "explanation..." links.
    $err->{idx} =  $err->{msg};
    $err->{idx} =~ s/"[^\"]*"/FOO/g;
    $err->{idx} =~ s/[^A-Za-z ]//g;
    $err->{idx} =~ s/\s+/ /g; # Collapse spaces
    $err->{idx} =~ s/(^\s|\s$)//g; # Remove leading and trailing spaces.
    $err->{idx} =~ s/(FOO )+/FOO /g; # Collapse FOOs. :-)
    $err->{idx} =~ s/FOO FOO/FOO/g; # Collapse FOOs. :-)

    $line = &ent($line); # Entity encode.
    $line =~ s/\t/ /g;   # Collapse TABs.

    print qq(  <li><em>Line <a href="#line-$err->{line}">$err->{line}</a>, column $col</em>: );
    print qq{<span class="msg">$err->{msg}</span>};

    if (defined $CFG->{'Error to URI'}->{$err->{idx}}) {
      print qq{ (<a href="$CFG->{'Msg FAQ URI'}#$CFG->{'Error to URI'}->{$err->{idx}}">explanation...</a>)};
    } elsif ($DEBUG) {
      print qq{ (<code style="background: red">"$err->{idx}"</code>)};
    }

    print qq(\n<pre>  <code class="input">$line</code>\n);
    print ' ' x ($col + 2); # 2 is the number of spaces before <code> above
    print ' ' x 4 if $col != $err->{char}; # only for truncated lines
    print qq(<span class="markup">^</span></pre>\n);
  }
  print "</ul>\n";
  print "<hr />\n";
  if ($File->{Version} eq 'unknown') {
    print "<p>Sorry, I can't validate this document.</p>";
  } elsif ($File->{Type} eq 'xml') {
    print "<p>Sorry, this document is not well-formed XML.</p>";
  } else {
    print "<p>Sorry, this document does not validate as $File->{Version}.</p>";
    &output_css_validator_blurb($File->{URI});
  }
}


#
# Output "This page is Valid" report.
sub report_valid {
  my $File   = shift;
  my $gifborder   = ' border="0"';
  my $xhtmlendtag = '';
  my($image_uri, $alttext, $gifhw);

  unless ($File->{Version} eq 'unknown' or defined $File->{Tentative}) {
    if ($File->{Version} =~ /^HTML 2\.0$/) {
      $image_uri = "$CFG->{'Home Page'}images/vh20";
      $alttext = "Valid HTML 2.0!";
      $gifborder = "";
    } elsif ($File->{Version} =~ /HTML 3\.2</) {
      $image_uri = "http://www.w3.org/Icons/valid-html32";
      $alttext = "Valid HTML 3.2!";
      $gifhw   = ' height="31" width="88"';
    } elsif ($File->{Version} =~ /HTML 4\.0<\/a> Strict$/) {
      $image_uri = "http://www.w3.org/Icons/valid-html40";
      $alttext = "Valid HTML 4.0!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
    } elsif ($File->{Version} =~ /HTML 4\.0<\/a> /) {
      $image_uri = "http://www.w3.org/Icons/valid-html40";
      $alttext = "Valid HTML 4.0!";
      $gifhw   = ' height="31" width="88"';
    } elsif ($File->{Version} =~ /HTML 4\.01<\/a> Strict$/) {
      $image_uri = "http://www.w3.org/Icons/valid-html401";
      $alttext = "Valid HTML 4.01!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
    } elsif ($File->{Version} =~ /HTML 4\.01<\/a> /) {
      $image_uri = "http://www.w3.org/Icons/valid-html401";
      $alttext = "Valid HTML 4.01!";
      $gifhw   = ' height="31" width="88"';
    } elsif ($File->{Version} =~ /XHTML 1\.0<\/a> /) {
      $image_uri = "http://www.w3.org/Icons/valid-xhtml10";
      $alttext = "Valid XHTML 1.0!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
      $xhtmlendtag = " /";
    } elsif ($File->{Version} =~ /XHTML Basic 1.0/) {
      $image_uri = "$CFG->{'Home Page'}/images/vxhtml-basic10";
      $alttext = "Valid XHTML Basic 1.0!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
      $xhtmlendtag = " /";
    } elsif ($File->{Version} =~ /XHTML 1.1/) {
      $image_uri = "http://www.w3.org/Icons/valid-xhtml11";
      $alttext = "Valid XHTML 1.1!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
      $xhtmlendtag = " /";
    } elsif ($File->{Version} =~ /HTML 3\.0/) {
      $image_uri = "$CFG->{'Home Page'}images/vh30";
      $alttext = "Valid HTML 3.0!";
    } elsif ($File->{Version} =~ /Netscape/) {
      $image_uri = "$CFG->{'Home Page'}images/vhns";
      $alttext = "Valid Netscape-HTML!";
    } elsif ($File->{Version} =~ /Hotjava/) {
      $image_uri = "$CFG->{'Home Page'}images/vhhj";
      $alttext = "Valid Hotjava-HTML!";
    }

    if (defined $image_uri) {
      print <<".EOF.";
    <h2 class="valid"><img src="$image_uri" alt="$alttext"$gifhw />
                      This Page Is Valid $File->{Version}!</h2>
.EOF.
      &print_jump_links($File);
      &print_tip_of_the_day($File, $CFG->{'Tips DB'});

      print <<".EOF.";
    <p>
      To show your readers that you have taken the care to create an
      interoperable Web page, you may display this icon on any page
      that validates. Here is the HTML you could use to add this icon
      to your Web page:
    </p>
    <pre>
    &lt;p&gt;
      &lt;a href="$CFG->{'Home Page'}check/referer"&gt;&lt;img$gifborder
          src="$image_uri"
          alt="$alttext"$gifhw$xhtmlendtag&gt;&lt;/a&gt;
    &lt;/p&gt;</pre>
    <p>
      If you like, you can download a copy of this image (in <a
      href="${image_uri}.png">PNG</a> or <a href="${image_uri}.gif">GIF</a>
      format) to keep in your local web directory, and change the HTML fragment
      above to reference your local image rather than the one on this server.
    </p>
.EOF.
    }
  }
  if (&is_xml($File->{Type}) and not $File->{DOCTYPE}) {
    print qq(  <h2 class="valid">This document is well-formed XML.</h2>\n);
  } elsif (defined $File->{Tentative}) {
    print qq(<h2 class="valid">This Page Is Valid $File->{Version}!</h2>);
    if ($File->{Tentative} == T_CHARSET_KLUDGE) {
      print "  <p>\n    This document would validate as $File->{Version} if you updated it to specify the Character Encoding used.\n  </p>\n";
    } else {
      print "  <p>\n    This document would validate as $File->{Version} if you updated it to match the Options used.\n  </p>\n";
    }
  } elsif ($File->{Version} eq 'unknown' or not defined $image_uri) {
    print qq(  <h2 class="valid">This document validates as the document type specified! (I don't have an icon for this one yet, sorry.)\n  </h2>\n);
  }

  unless ($File->{'Is Upload'}) {
    my $thispage = $File->{Env}->{'Self URI'};
    $thispage .= qq(?uri=$File->{URI});
    $thispage .= ';ss=1'      if $File->{Opt}->{'Show Source'};
    $thispage .= ';sp=1'      if $File->{Opt}->{'Show Parsetree'};
    $thispage .= ';noatt=1'   if $File->{Opt}->{'No Attributes'};
    $thispage .= ';outline=1' if $File->{Opt}->{'Outline'};

    &output_css_validator_blurb($File->{URI});

    print <<"EOHD";
  <p>
    If you would like to create a link to <em>this</em> page (i.e., this
    validation result) to make it easier to re-validate this page in the
    future or to allow others to validate your page, the URI is:
  </p>

  <blockquote>
    <p><code><a href="$thispage">$thispage</a></code></p>
  </blockquote>

  <p>
    (Or, you can just add the current page to your bookmarks or hotlist.)
  </p>
EOHD
  }
}


#
# Produce an outline of the document based on Hn elements from the ESIS.
sub outline {
  my $File = shift;

  print <<'EOF';
  <div id="outline" class="mtb">
    <hr />
    <h2><a name="outline">Outline</a></h2>
    <p>
      Below is an outline for this document, automatically generated from the
      heading tags (<code>&lt;H1&gt;</code> through <code>&lt;H6&gt;</code>.)
    </p>
EOF

  my $prevlevel = 0;
  my $indent    = 0;
  my $level     = 0;

  for (1 .. $#{$File->{ESIS}}) {
    my $line = $File->{ESIS}->[$_];
    next unless $line =~ /^\(H([1-6])$/i;
    $prevlevel = $level;
    $level     = $1;

    print "    </ul>\n" x ($prevlevel - $level); # perl is so cool.
    if ($level - $prevlevel == 1) {print "    <ul>\n"};
    foreach my $i (($prevlevel + 1) .. ($level - 1)) {
      print qq(  <ul>\n    <li class="warning">A level $i heading is missing!</li>\n);
    }
    if ($level - $prevlevel > 1) {print "    <ul>\n"};

    $line       = '';
    my $heading = '';
    until (substr($line, 0, 3) =~ /^\)H$level/i) {
      $line = $File->{ESIS}->[$_++];
      $line =~ s/\\011/ /g;
      $line =~ s/\\012/ /g;
      if ($line =~ /^-/) {
	my $headcont = $line;
	substr($headcont, 0, 1) = " ";
	$headcont =~ s/\\n/ /g;
	$heading .= $headcont;
      } elsif ($line =~ /^AALT CDATA( .+)/i) {
	my $headcont = $1;
	$headcont =~ s/\\n/ /g;
	$heading .= $headcont;
      }
    }

    $heading = substr($heading, 1); # chop the leading '-' or ' '.
    $heading = &ent($heading);
    print "    <li>$heading</li>\n";
  }
  print "    </ul>\n" x $level;
  print <<'EOF';
    <p>
      If this does not look like a real outline, it is likely that the
      heading tags are not being used properly. (Headings should reflect
      the logical structure of the document; they should not be used simply
      to add emphasis, or to change the font size.)
    </p>
    </div>
EOF
}


#
# Create a HTML representation of the document.
sub show_source {
  my $File = shift;
  my $line = 1;

  print <<'EOF';
  <div id="source" class="mtb">
    <hr />
    <h2><a name="source">Source Listing</a></h2>

    <p>Below is the source input I used for this validation:</p>
    <pre>
EOF

  for (@{$File->{Content}}) {
    printf "<a name=\"line-%s\">%4d</a>: %s\n", $line, $line, ent $_;
    $line++;
  }
  print "    </pre>\n  </div>";
}


#
# Create a HTML Parse Tree of the document for validation report.
sub parse_tree {
  my $File = shift;

  print <<'EOF';
  <div id="parse" class="mtb">
    <hr />
    <h2><a name="parse">Parse Tree</a></h2>
EOF
  if ($File->{Opt}->{'No Attributes'}) {
    print <<'EOF';
    <p class="note">
      I am excluding the attributes, as you requested.
    </p>
EOF
  } else {
    print <<'EOF';
    <p class="note">
      You can also view this parse tree without attributes by selecting the
      appropriate option on <a href="./#byURI">the form</a>.
    </p>
EOF
  }

  my $indent   = 0;
  my $prevdata = '';

  print "<pre>\n";
  foreach my $line (@{$File->{ESIS}}) {
    if ($File->{Opt}->{'No Attributes'}) { # don't show attributes
      next if $line =~ /^A/;
      next if $line =~ /^\(A$/;
      next if $line =~ /^\)A$/;
    }

    $line =~ s/\\n/ /g;
    $line =~ s/\\011/ /g;
    $line =~ s/\\012/ /g;
    $line =~ s/\s+/ /g;
    next if $line =~ /^-\s*$/;

    if ($line =~ /^-/) {
      substr($line, 0, 1) = ' ';
      $prevdata .= $line;
      next;
    } elsif ($prevdata) {
      $prevdata = &ent($prevdata);
      $prevdata =~ s/\s+/ /go;
      print wrap(' ' x $indent, ' ' x $indent, $prevdata), "\n";
      undef $prevdata;
    }

    $line = &ent($line);
    if ($line =~ /^\)/) {
      $indent -= 2;
    }

    my $printme;
    chomp($printme = $line);
    $printme =~ s{^([()])(.*)}	# reformat and add links on HTML elements
		 { my $close = '';
		      $close = "/" if $1 eq ")";	# ")" -> close-tag
		   "&lt;" . $close . "<a href=\"" .
		   $CFG->{'Element Ref URI'} . $CFG->{'Element Map'}->{lc($2)} .
		   "\">$2<\/a>&gt;"
		 }egx;
    $printme =~ s,^A,  A,;	# indent attributes a bit
    print ' ' x $indent, $printme, "\n";
    if ($line =~ /^\(/) {
      $indent += 2;
    }
  }
  print "</pre>\n";
  print "</div>\n";
}


#
# Do an initial parse of the Document Entity to extract charset and FPI.
sub preparse {
  my $File = shift;

  my $dtd = sub {
    return if $File->{Root};
    ($File->{Root}, $File->{DOCTYPE}) = shift =~  m(<!DOCTYPE\s+(\w+)\s+PUBLIC\s+(?:[\'\"])([^\"\']+)(?:[\"\']).*>)si;
  };
  my $pi = sub {
    return if $File->{Charset}->{XML};
    my $pi = shift;
    return unless $pi =~ m(<\?xml);
    $pi =~ m(<\?xml[^>]*\sencoding\s*=\s*([\"\'])([A-Za-z][-A-Za-z0-9._]*)\1)s;
    warn qq("$1" - "$2"\n);
    $File->{Charset}->{XML} = lc $2;
  };
  my $start = sub {
    my $tag  = shift;
    my $attr = shift;
    my %attr = map {lc($_) => $attr->{$_}} keys %{$attr};

    if ($File->{Root}) {
      if (lc $tag eq 'meta') {
	if (lc $attr{'http-equiv'} eq 'content-type') {
	  if ($attr{content} =~ m(charset\s*=[\s\"\']*([^\s;\"\'>]*))si) {
	    $File->{Charset}->{META} = lc $1;
          }
	}
      }
      return unless $tag eq $File->{Root};
    } else {
      $File->{Root} = $tag;
    }
    if ($attr->{xmlns}) {$File->{Namespace} = $attr->{xmlns}};
  };

  my $p =  HTML::Parser->new(api_version => 3);
  $p->xml_mode(TRUE);
  $p->ignore_elements('BODY');
  $p->ignore_elements('body');
  $p->handler(declaration => $dtd, 'text');
  $p->handler(process => $pi, 'text');
  $p->handler(start => $start, 'tag,attr');
  $p->parse(join "\n", @{$File->{Content}});

  $File->{DOCTYPE} = '' unless defined $File->{DOCTYPE};

  return $File;
}

#
# Print out the raw ESIS output for debugging.
sub show_esis ($) {
  print <<'EOF';
  <div id="raw_esis" class="mtb">
    <hr />
    <h2><a name="raw_esis">Raw ESIS Output</a></h2>
    <pre>
EOF
  for (@{shift->{'DEBUG'}->{ESIS}}) {
    s/\\012//g;
    s/\\n/\n/g;
    print ent $_;
  }
  print "    </pre>\n  </div>";
}

#
# Print out the raw error output for debugging.
sub show_errors ($) {
  print <<'EOF';
  <div id="raw_errors" class="mtb">
    <hr />
    <h2><a name="raw_errors">Raw Error Output</a></h2>
    <pre>
EOF
  for (@{shift->{'DEBUG'}->{Errors}}) {print ent $_};
  print "    </pre>\n  </div>";
}


#
# Preprocess CGI parameters.
sub prepCGI {
  my $File = shift;
  my    $q = shift;

  # Avoid CGI.pm's "exists but undef" behaviour.
  if (scalar $q->param) {
    foreach my $param ($q->param) {
      next if $param eq 'uploaded_file'; # 'uploaded_file' contains data.
      $q->param($param, TRUE) unless $q->param($param);
    }
  }

  # Futz the URI so "/referer" works.
  $q->param('uri', $q->referer) if $q->path_info eq '/referer';

  # USe HTTP Referer if uri=referer.
  $q->param('uri', $q->referer) if $q->param('uri') =~ m(referer)i;

  # Use "url" unless a "uri" was also given.
  $q->param('uri', $q->param('url')) if $q->param('url') and not $q->param('uri');

  # Supercede URI with an uploaded file.
  if ($q->param('uploaded_file')) {
    $q->param('uri', 'upload://' . $q->param('uploaded_file'));
    $File->{'Is Upload'} = TRUE; # Tag it for later use.
  }

  # Supercede URI with an uploaded fragment.
  if ($q->param('fragment')) {$q->param('uri', 'upload://Form Submission')};

  # Munge the URI to include commonly omitted prefix.
  $q->param('uri', 'http://' . $q->param('uri')) if $q->param('uri') =~ m(^www)i;

  return $q;
}

#
# Preprocess SSI files.
sub prepSSI {
  my $opt = shift;
  my $ssi;

  open FH, $opt->{File} or carp "open($opt->{File}) returned: $!\n";
  $ssi = join '', <FH>;
  close FH       or carp "close($opt->{File}) returned: $!\n";

  $ssi =~ s/<!--\#echo var="title" -->/$opt->{Title}/g
    if defined $opt->{Title};

  $ssi =~ s/<!--\#echo var="date" -->/$opt->{Date}/g
    if defined $opt->{Date};

  $ssi =~ s/<!--\#echo\s+var="revision"\s+-->/$opt->{Revision}/g
    if defined $opt->{Revision};

  return $ssi;
}


#
# Check if the URI looks like one we want to retrieve.
#
# Returns FALSE if URI is ok, or an error message suitable for output.
#
# @@@FIXME@@@:
#   Disable checking if the URI is local (or private) for security reasons,
#   or at least make it configurable to do so.
#   eg. /^(localhost(\.localdomain)?|127\.)$/ (+ private networks)
#
sub uri_rejected {
  my $File    = shift;
  my $uri     = URI->new($File->{Opt}->{URI});
  my $scheme  = $uri->scheme();

  my($handler, $ret);

  #
  # If we don't have an SSL implementation for use with LWP, CGI::Carp bombs
  # here and the script dies. So, we need to "local"ize $SIG{__DIE__} here.
  eval {local $SIG{__DIE__}; $handler = LWP::Protocol::implementor($scheme)};

  # No implementor for the scheme, or a (disabled) "file://" URI.
  if ($@ or $scheme eq 'file' or $handler eq 'LWP::Protocol::file') {
    undef $handler;
  }

  if (defined $handler) {
    return FALSE;
  } else {
    $scheme = $scheme || 'undefined';
    $ret =  <<"EOF";
    <div class="error">
      <p>
        Sorry, this type of <a
          href="http://www.w3.org/Addressing/#terms">URI</a>
        (<q>$scheme</q>) is not supported by this service. Please check
        that you entered the URI correctly.
      </p>
      <p>URIs should be in the form: <code>http://validator.w3.org/</code></p>
      <p>
        If you entered a valid URI using a scheme that we should support,
        please let us know as outlined on our
        <a href="/feedback.html">Feedback page</a>. Make sure to include the
        specific URI you would like us to support, and if possible provide a
        reference to the relevant standards document describing the URI scheme
        in question.
      </p>
    </div>
EOF
  return $ret;
  }
}


#
# Utility subs to tell if type "is" something.
sub is_xml    {shift =~ m(^[^+]+\+xml$)};
sub is_svg    {shift =~ m(^svg)};
sub is_smil   {shift =~ m(^smil)};
sub is_html   {shift =~ m(^html$)};
sub is_xhtml  {shift =~ m(^xhtml)};
sub is_mathml {shift =~ m(^mathml)};


#
# Sanity check charset info and add any warnings necessary.
sub validate_charset {
  my $File = shift;
  #
  # Handle the case where there was no charset to be found.
  # (This is a different issue from whether an override was given!)
  unless ($File->{Charset}->{Use}) {
    if (&is_xml($File->{Type})) {
      $File->{Charset}->{Use} = 'UTF-8'; # @@@TODO@@@: Should detect UTF-8 vs. UTF-16!
    } else {
      &add_warning($File, <<"      .EOF.");
      <strong>No Character Encoding detected!</strong>
      To ensure correct validation, processing, and display,
      it is important that the character encoding is properly
      labeled.
      <a href="http://www.w3.org/International/O-charset.html">More
      information...</a>
      .EOF.
      $File->{Tentative} |= T_CHARSET_KLUDGE; # Would be T_WARN, but the complaints...
    }
  }

  #
  # If we have a charset field in the request, we use it
  if ($File->{Opt}->{Charset}) {
    if ($File->{Opt}->{Charset} =~ m(detect automatically)i) {
      $File->{Opt}->{Charset} = '';
    } else {
      $File->{Opt}->{Charset} =~ /^(\w+)/;
      $File->{Opt}->{Charset} = lc $1;

      &add_warning($File, <<"      .EOF.");
      <strong>Character Encoding Override in effect!</strong>
      The detected character encoding,
      &#171;<code>$File->{Charset}->{Use}</code>&#187;, has been supressed and the
      character encoding &#171;<code>$File->{Opt}->{Charset}</code>&#187;
      used instead.
      .EOF.
      $File->{Tentative} |= T_ERROR;
      $File->{Charset}->{Use} = $File->{Opt}->{Charset};
    }
  }

  #
  # Add a warning if there was charset info in the HTTP header, but it was
  # later overridden by a META element or XML Declaration.
  if ($File->{Charset}->{HTTP}) {
    if ($File->{Charset}->{META}) {
      unless ($File->{Charset}->{META} eq $File->{Charset}->{HTTP}) {
	&add_warning($File, <<"        .EOF.");
      <strong>Character Encoding mismatch!</strong>
      The character encoding specified in the HTTP header,
      &#171;<code>$File->{Charset}->{HTTP}</code>&#187;, is different from the
      value &#171;<code>$File->{Charset}->{META}</code>&#187; in the META element.
      I will use &#171;<code>$File->{Charset}->{Use}</code>&#187; for this validation.
        .EOF.
      }
    } elsif ($File->{Charset}->{XML}) {
      unless ($File->{Charset}->{XML} eq $File->{Charset}->{HTTP}) {
	&add_warning($File, <<"        .EOF.");
      <strong>Character Encoding mismatch!</strong>
      The character encoding specified in the HTTP header,
      &#171;<code>$File->{Charset}->{HTTP}</code>&#187;, is different from the
      one value &#171;<code>$File->{Charset}->{XML}</code>&#187; in the XML
      declaration I will use &#171;<code>$File->{Charset}->{Use}</code>&#187;
      for this validation.
        .EOF.
      }
    }
  }

  return $File;
}


#
# Check Encoding and Transliterate.
sub validate_encoding {
  my $File = shift;

  my @lines;

  unless ($File->{Charset}->{Use} =~ m(utf-8)i) {
    my ($command, $result_charset) = split " ", $CFG->{Charsets}->{$File->{Charset}->{Use}}, 2;

    if ($command eq 'I') {
      eval {my $c = Text::Iconv->new($result_charset, 'utf-8')};
      $command = '' if $@;
    } elsif ($command eq 'X') {
      $@ = "$File->{Charset}->{Use} undefined; replace by $result_charset";
    }

    if ($command ne 'I') {
      $File->{'Error Flagged'} = TRUE;
      $File->{'Error Message'} = <<"      .EOF.";
        <p>Sorry!
          A fatal error occurred when attempting to transcode the character encoding
          of the document. Either we do not support this character encoding yet, or you 
          have specified a non-existent character encoding (often a misspelling).
        </p>
        <p>The detected character encoding was "$File->{Charset}->{Use}".</p>
        <p>The error was "$@".</p>
        <p>The command was "$command".</p>
        <p>The Result Charset was "$result_charset".</p>
        <p>The Use Charset was "$File->{Charset}->{Use}".</p>
        <p>
          If you believe the character encoding to be valid you can submit a request for
          that character encoding (see the <a href="/feedback.html">feedback page</a>
          for details) and we will look into supporting it in the future.
        </p>
      .EOF.
      return $File;
    }

    my $c = Text::Iconv->new($result_charset, 'utf-8');
    my $line = 0;
    for (@{$File->{Content}}) {
      my $in = $_;
      $line++;
      $_ = $c->convert($_); # $_ is local!!
      push @lines, $line if ($in ne "" and $_ eq "");
    }
  }

  # check correctness of UTF-8 both for UTF-8 input and for conversion results
  if ($File->{Charset}->{Use}) {
    for (my $i = 0; $i < $#{$File->{Content}}; $i++) {
      # substitution needed for very long lines (>32K),
      # to avoid backtrack stack overflow
      local $_ = $File->{Content}->[$i];
      s/  [\x00-\x7F]                           # ASCII
        | [\xC2-\xDF]        [\x80-\xBF]        # non-overlong 2-byte sequences
        |  \xE0[\xA0-\xBF]   [\x80-\xBF]        # excluding overlongs
        | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}     # straight 3-byte sequences
        |  \xED[\x80-\x9F]   [\x80-\xBF]        # excluding surrogates
        |  \xF0[\x90-\xBF]   [\x80-\xBF]{2}     # planes 1-3
        | [\xF1-\xF3]        [\x80-\xBF]{3}     # planes 4-15
        |  \xF4[\x80-\x8F][\x80-\xBF]{2}        # plane 16
       //xg;
      push @lines, $i if length;
    }
  }

  if (scalar @lines) {
    $File->{'Error Flagged'} = TRUE;
    my $s = $#lines ? 's' : '';
    my $lines = join ', ', @lines;
    $File->{'Error Message'} = <<"    .EOF.";
      <p class="error">
        Sorry, I am unable to validate this document because on
        <strong>line$s $lines</strong> it contained
        some byte$s that I cannot interpret as
        <code>$File->{Charset}->{Use}</code>.
        Please check both the content of the file
        and the character encoding indication.
      </p>
    .EOF.
    return $File;
  }
  return $File;
}
