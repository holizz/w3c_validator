#!/usr/bin/perl -Tw
#
# W3C HTML Validation Service
# A CGI script to retrieve and validate an HTML file
#
# Copyright 1995-2001 Gerald Oskoboiny <gerald@w3.org>
# for additional contributors, see http://dev.w3.org/cvsweb/validator/
#
# This source code is available under the license at:
#     http://www.w3.org/Consortium/Legal/copyright-software
#
# $Id: check,v 1.200.2.5 2002-03-18 00:32:47 link Exp $

#
# We need Perl 5.004.
require 5.004;

#
# Load modules
use strict;
use LWP::UserAgent;
use URI;
use URI::Escape;
use CGI::Carp;
use CGI qw(:cgi -newstyle_urls -private_tempfiles);
use Text::Wrap;
use IPC::Open3;
use IO::File;
use Text::Iconv; # on debian: apt-get install libtext-iconv-perl 
use HTML::Parser 3.25; # Need 3.25 for $p->ignore_elements.
                       # DWC tweaks this in his local set-up.


#############################################################################
# Constant definitions
#############################################################################

#
# Define global constants
use constant TRUE  => 1;
use constant FALSE => 0;
use constant UNDEF => undef;
use constant DEBUG => 0;

#
# Tentative Validation Severeties.
use constant T_DEBUG =>  1; # 0000 0001
use constant T_INFO  =>  2; # 0000 0010
use constant T_WARN  =>  4; # 0000 0100
use constant T_ERROR =>  8; # 0000 1000
use constant T_FATAL => 16; # 0001 0000

use constant T_CHARSET_KLUDGE => 128; # 1000 0000


#
# Define global variables
use vars qw($DEBUG); # Switch to turn debugging on and off.
use vars qw($VERSION $DATE $MAINTAINER $NOTICE);               # Strings.
use vars qw($frag $pub_ids $element_uri $file_type $doctypes $charsets);
                                                               # Cfg hashes.

$DEBUG += 1 unless $ENV{SERVER_PORT} == 80;

#
# Paths and file locations

#
# CONFIG: Change this to the directory that contains "htdocs/".
my $base_path = '/usr/local/validator/';

my $html_path = $base_path . 'htdocs/';
my $elem_db   = $html_path . 'config/eref.cfg';
my $fpis_db   = $html_path . 'config/fpis.cfg';
my $frag_db   = $html_path . 'config/frag.cfg';
my $type_db   = $html_path . 'config/type.cfg';
my $dtds_db   = $html_path . 'config/doctypes.cfg';
my $chst_db   = $html_path . 'config/charset.cfg';
my $tips_db   = $html_path . 'config/tips.html';
my $sgmlstuff = $html_path . 'sgml-lib';

#
# Executables and binaries
my $sp = '/usr/local/bin/onsgmls';

#
# URIs and fragments
my $uri_def_uri	= 'http://www.w3.org/Addressing/#terms';

#
# Strings
$VERSION    =  q$Revision: 1.200.2.5 $;
$VERSION    =~ s/Revision: ([\d\.]+) /$1/;
$DATE       =  q$Date: 2002-03-18 00:32:47 $;
$MAINTAINER =  'gerald@w3.org';
$NOTICE     =  ''; # "<p><strong>Note: This service will be ...</strong>";

#
# Read configuration files.
$frag        = &read_cfg($frag_db); # FPIs    -> plain text version string
$pub_ids     = &read_cfg($fpis_db); # Errors  -> fragment identifier
$element_uri = &read_cfg($elem_db); # Element -> URI fragment
$file_type   = &read_cfg($type_db); # Content -> File -type
$doctypes    = &read_cfg($dtds_db); # Name    -> doctype
$charsets    = &read_cfg($chst_db); # charset -> iconv parameter

#
# Get rid of (possibly insecure) $PATH.
delete $ENV{PATH};


################################################################################
#### Process CGI variables and initialize. #####################################
################################################################################

#
# Create a new CGI object.
my $q = new CGI;

#
# The datastructure that will hold all session data.
my $File;

##############################################
# Populate $File->{Env} -- Session Metadata. #
##############################################

#
# The URL to this CGI Script.
$File->{Env}->{'Self URI'} = $q->url(-query => 0);


################################################
# Populate $File->{Cfg} -- Configuration Data. #
################################################

#
# The URI to various things.
$File->{Cfg}->{'Home Page'}       = 'http://validator.w3.org/';
$File->{Cfg}->{'Msg FAQ URI'}     = 'http://validator.w3.org/docs/errors.html';
$File->{Cfg}->{'Element Ref URI'} = 'http://www.htmlhelp.com/reference/html40/';


#########################################
# Populate $File->{Opt} -- CGI Options. #
#########################################

#
# Preprocess the CGI parameters.
$q = &prepCGI($File, $q);

#
# Set session switches.
$File->{Opt}->{'Weblint'}        = $q->param('weblint') ? TRUE : FALSE;
$File->{Opt}->{'Outline'}        = $q->param('outline') ? TRUE : FALSE;
$File->{Opt}->{'Show Source'}    = $q->param('ss')      ? TRUE : FALSE;
$File->{Opt}->{'Show Parsetree'} = $q->param('sp')      ? TRUE : FALSE;
$File->{Opt}->{'No Attributes'}  = $q->param('noatt')   ? TRUE : FALSE;
$File->{Opt}->{'Show ESIS'}      = $q->param('esis')    ? TRUE : FALSE;
$File->{Opt}->{'Show Errors'}    = $q->param('errors')  ? TRUE : FALSE;
$File->{Opt}->{'DOCTYPE'}        = $q->param('doctype') if $q->param('doctype');
$File->{Opt}->{'Charset'}        = $q->param('charset') if $q->param('charset');
$File->{Opt}->{'URI'}            = $q->param('uri')     if $q->param('uri');


#
# Get the file and metadata.
if    ($q->param('uploaded_file')) {$File = &handle_file($q, $File)}
elsif ($q->param('fragment'))      {$File = &handle_frag($q, $File)}
elsif ($q->param('uri'))           {$File = &handle_uri( $q, $File)};

#
# Get rid of the CGI object.
undef $q;


################################################################################
#### Output validation results. ################################################
################################################################################

#
# A string containing the HTML header for validation results.
# We save it in a string instead of printing it in case we need to abort before
# we have any meaningfull results to report. @@ May not be necessary!
$File->{Results} = <<"EOF";
Content-Language: en
Content-Type: text/html; charset=utf-8

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
  <head>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'>
    <title>W3C HTML Validation Service Results</title>
    <link rev="made" href="mailto:$MAINTAINER">
    <style type="text/css" media="screen">\@import "/results.css";</style>
  </head>

  <body>
    <div>
      <p class="navbar">
        <span class="hideme"><a href="#title" title="Skip past navigation to main part of page">Skip Navigation</a> |</span>
        <a href="/" title="Go to the Home Page for tThe W3C HTMl Validation Service">[&nbsp;Home&nbsp;Page&nbsp;]</a> <span class="hideme">|</span>
        <a href="/docs/" title="Documentation for this Service">Documentation</a> <span class="hideme">|</span>
        <a href="/source/" title="Information on Source Availability">Source&nbsp;Code</a> <span class="hideme">|</span>
        <a href="/whatsnew.html" title="The changes made to this service recently">What's&nbsp;New</a> <span class="hideme">|</span>
        <a href="/feedback.html" title="How to provide feedback on this service">Feedback</a> <span class="hideme">|</span>
        <a href="/about.html" title="Information About this Service">About...</a> <span class="hideme">|</span>
      </p>
      <p class="navbar">
        <a href="http://jigsaw.w3.org/css-validator/" class="offsite" title="The W3C CSS Validator">CSS&nbsp;Validator</a> <span class="hideme">|</span>
        <a href="/checklink" class="offsite" title="The W3C Link Checker">Link&nbsp;Checker</a> <span class="hideme">|</span>
        <a href="http://www.w3.org/People/Raggett/tidy/" class="offsite" title="The HTML Tidy Home Page">HTML&nbsp;Tidy</a> <span class="hideme">|</span>
      </p>
      <p class="navbar">
        <a href="http://www.w3.org/MarkUp/" class="offsite" title="The W3C HTML Home Page">HTML&nbsp;Home</a> <span class="hideme">|</span>
        <a href="http://www.w3.org/TR/xhtml1/" class="offsite" title="The XHTML 1.0 Reccommendation">XHTML&nbsp;1.0</a> <span class="hideme">|</span>
        <a href="http://www.w3.org/TR/html401/" class="offsite" title="The HTML 4.01 Reccommendation">HTML&nbsp;4.01</a> <span class="hideme">|</span>
      </p>
      <h1 id="title"><a href="http://www.w3.org/"><img height="48" alt="W3C" id="logo"
         src="http://www.w3.org/Icons/WWW/w3c_home" /></a> HTML Validation Service Results</h1>
    </div>
    $NOTICE
EOF


#
# Punt if we don't recognize this URI scheme.
# @@ LWP does a whole bunch more: transparently!
unless ($File->{Opt}->{URI} =~ m(^(http|upload)://)) {
  print $File->{Results};
  print <<"EOF";
  <p>
    Sorry, this type of <a href="http://www.w3.org/Addressing/#terms">URI</a>
    is not supported by this service.
  </p>
  <p>
    URIs should be in the form:
  </p>
  <blockquote>
    <code>$File->{Cfg}->{'Home Page'}</code>
  </blockquote>
  <p>
    (There are other types of URIs, too, but only <code>http://</code> URIs
    are currently supported by this service.)
  </p>
EOF
  &clean_up_and_exit($File);
}


#
# Abort if there was no document type mapping for this Content-Type, in which
# case the document type will be equal to the content type (contains a "/").
if ($File->{'Type'} =~ m(/) and not $q->param('uploaded_file')) {
  print $File->{Results};
  print <<"EOF";
    <p class="error">
      Sorry, I am unable to validate this document because its returned
      content-type was <code>$File->{Type}</code>, which is not
      currently supported by this service.
    </p>
EOF
  &clean_up_and_exit($File);
}

#
# Overall parsing algorithm for documents returned as text/html:
#
# For documents that come to us as text/html,
#
#  1. check if there's a doctype
#  2. if there is a doctype, parse/validate against that DTD
#  3. if no doctype, check for an xmlns= attribute on the first element
#  4. if there is an xmlns= attribute, check for XML well-formedness
#  5. if there is no xmlns= attribute, and no DOCTYPE, punt.
#

#
# Detect and remove a UTF-8 BOM.
$File->{Content}[0] =~ s/^\xEF\xBB\xBF//
  and &add_warning($File, <<".EOF.");
     <em>Note:</em> UTF-8 'BOM' detected and removed. (This message is
     informational. See the
     <a href="$File->{Cfg}->{'Msg FAQ URI'}#utf8-bom">explanation</a> for details.)
.EOF.


#
# Override DOCTYPE if user asked for it.
if (defined $File->{Opt}->{DOCTYPE}
    and not $File->{Opt}->{DOCTYPE} =~ /(Inline|detect)/i) {
  $File->{Content} = &supress_doctype($File->{Content});
  unshift @{$File->{Content}}, $doctypes->{$File->{Opt}->{DOCTYPE}};
  my $dtd = ent($File->{Opt}->{DOCTYPE});
  &add_warning($File, <<".EOF.");
  <strong>DOCTYPE Override in effect!</strong> Any DOCTYPE Declaration in the
  document has been supressed and the DOCTYPE for &#171;<code>$dtd</code>&#187;
  inserted instead. The document will not be Valid until you alter the source
  file to reflect this new DOCTYPE.
.EOF.
  $File->{Tentative} |= T_ERROR; # Tag it as Invalid.
}

#
# Try to extract a DOCTYPE or xmlns.
$File = &preparse($File);


#
# Set document type to XHTML if the DOCTYPE was for XHTML.
# Set document type to MathML if the DOCTYPE was for MathML.
# This happens when the file is served as text/html
$File->{Type} = 'xhtml'  if $File->{DOCTYPE} =~ /xhtml/i;
$File->{Type} = 'mathml' if $File->{DOCTYPE} =~ /mathml/i;


#
# Figure out which charset was detected.
if    ($File->{HTTP_Charset}) {$File->{Charset} = $File->{HTTP_Charset}}
elsif ($File->{XML_Charset})  {$File->{Charset} = $File->{XML_Charset}}
elsif ($File->{META_Charset}) {$File->{Charset} = $File->{META_Charset}}
else  {                        $File->{Charset} = 'unknown'}

# If we have a charset field in the request, we use it
if ($File->{Opt}->{Charset} and $File->{Opt}->{Charset} ne 'unknown'
               and $File->{Opt}->{Charset} ne '(detect automatically)') {
  $File->{Opt}->{Charset} =~ /^([^ ]*)/;
  $File->{Use_Charset} = lc $1;
}
else { $File->{Use_Charset} = $File->{Charset}; }

#
# Setup SP environment for the charset.
if ($File->{Use_Charset} ne 'unknown') {
  $ENV{SP_CHARSET_FIXED} = 'YES';
  $ENV{SP_ENCODING}      = 'utf-8';
}

#
# Print header and jump links.
print $File->{Results}, &build_jump_links($File);


#
# Print different things if we got redirected or had a file upload.
#if (URI::eq("$File->{Opt}->{URI}", $q->param('uri'))) { # @@@FIXME@@@: Temorarily Broken. :-)
if (TRUE) { # @@ Need to stringify here?
  &add_table($File, qq(<label title="Address of Page to Validate" for="uri">Address</label>),
	     '<input type="text" id="uri" name="uri" size="'
	     . (length($File->{Opt}->{URI}) + 2)
	     . '" value="' . $File->{Opt}->{URI} . '" />'
             . ' [<a title="Go to the entered URI" href="' . $File->{Opt}->{URI} . '">Go to...</a>]');
} elsif ($q->param('uploaded_file')) {
  &add_table($File, "File", $File->{Opt}->{URI});
} else {
  &add_table($File, qq(<label title="Address of Page to Validate" for="uri"><a href="$uri_def_uri">URI</a></label>),
	     '<input type="text" id="uri" name="uri" size="'
	     . (length($File->{Opt}->{URI}) + 2)
	     . '" value="' . $File->{Opt}->{URI} . '" />'
             . ' [<a href="' . $File->{Opt}->{URI} . '">Go to URI</a>]');
  &add_warning($File, '<em>Note:</em> The URI you gave me, &#171;<code>' .
	       $q->param('uri') . '</code>&#187;, ' .
	       'returned a redirect to ' .
	       '&#171;<code>' . $File->{Opt}->{URI} . '</code>&#187;.');
}

&add_table($File, "Last Modified", $File->{Modified})  if $File->{Modified};
&add_table($File, "Server", $File->{Server})  if $File->{Server};
&add_table($File, "Content Length", $File->{Size})  if $File->{Size};
&add_table($File, "Detected Character Encoding", "<code>$File->{Charset}</code>");
&add_table($File, "Used Character Encoding", "<code>$File->{Use_Charset}</code>")
    unless $File->{Charset} eq $File->{Use_Charset};
unless ($File->{Opt}->{'Is Upload'}) { # @@@FIXME@@@: Temporarily Broken.
#  &add_table($File, qq(<label title="Select Character Encoding" for="charset">Select Character Encoding</label>),
#	     $q->popup_menu(-name => 'charset', -id => 'charset',
#			    -values => [
#					'(detect automatically)',
#					'utf-8 (Unicode, worldwide)',
#					'iso-8859-1 (Western Europe)',
#					'iso-8859-2 (Central Europe)',
#					'iso-8859-3 (Maltese)',
#					'iso-8859-4 (Baltic Rim)',
#					'iso-8859-5 (Cyrillic)',
#					'iso-8859-6-i (Arabic)',
#					'iso-8859-7 (Greek)',
#					'iso-8859-8-i (Hebrew)',
#					'iso-8859-9 (Turkish)',
#					'iso-8859-10 (Latin 6)',
#					'iso-8859-13 (Latin 7)',
#					'iso-8859-14 (Celtic)',
#					'iso-8859-15 (Latin 9)',
#					'us-ascii (basic English)',
#					'euc-jp (Japanese, Unix)',
#					'shift_jis (Japanese, Win/Mac)',
#					'iso-2022-jp (Japanese, email)',
#					'euc-kr (Korean)',
#					'gb2312 (Chinese, simplified)',
#					'big5 (Chinese, traditional)',
#					'tis-620 (Thai)',
#					'koi8-r (Russian)',
#					'koi8-u (Ukrainian)',
#					'macintosh (MacRoman)',
#					'windows-1250 (Central Europe)',
#					'windows-1251 (Cyrillic)',
#					'windows-1252 (Western Europe)',
#					'windows-1253 (Greek)',
#					'windows-1254 (Turkish)',
#					'windows-1255 (Hebrew)',
#					'windows-1256 (Arabic)',
#					'windows-1257 (Baltic Rim)',
#				       ],
#			   )
#	    );
}

if ($File->{HTTP_Charset} ne $File->{META_Charset}) {
  &add_warning($File, <<"EOHD");
      <strong>Character Encoding mismatch!</strong>
      The character encoding specified in the HTTP header
      (&#171;<code>$File->{HTTP_Charset}</code>&#187;) is different from the
      one specified in the META element
      (&#171;<code>$File->{META_Charset}</code>&#187;).
      I will use &#171;<code>$File->{Charset}</code>&#187; for this validation.
EOHD
} elsif ($File->{HTTP_Charset} ne $File->{XML_Charset}) {
  &add_warning($File, <<"EOHD");
      <strong>Character Encoding mismatch!</strong>
      The character encoding specified in the HTTP header
      (&#171;<code>$File->{HTTP_Charset}</code>&#187;) is different from the
      one specified in the XML declaration
      (&#171;<code>$File->{XML_Charset}</code>&#187;).
      I will use &#171;<code>$File->{Charset}</code>&#187; for this validation.
EOHD
}
if ($File->{Use_Charset} ne $File->{Charset}) {
  &add_warning($File, <<"EOHD");
      <strong>Character Encoding Override in effect!</strong>
      The detected character encoding
      (&#171;<code>$File->{Charset}</code>&#187;) has been supressed and the
      character encoding (&#171;<code>$File->{Use_Charset}</code>&#187;)
      used instead.
EOHD
  $File->{Tentative} |= T_ERROR;
}
if ($File->{Use_Charset} eq 'unknown') {
  &add_warning($File, <<"EOHD");
      <strong>No Character Encoding detected!</strong>
      To assure correct validation, processing, and display,
      it is important that the character encoding is properly
      labeled.
      <a href='http://www.w3.org/International/O-charset.html'>Further
      explanations</a>.
EOHD
  $File->{Tentative} |= T_DEBUG; # WOuld be T_WARN, but the complaints...
}
## special warning because of iconv bug
if ( $File->{Use_Charset} eq 'macintosh' ) {
  &add_warning($File, "'macintosh' <code>charset</code> not completely supported, sorry (might get errors saying 'illegal character number 0').");
}

{  # block for character conversion and checking
  my @lines;
  unless ($File->{Use_Charset} eq 'utf-8' or $File->{Use_Charset} eq 'unknown') {
    my ($command, $result_charset) = split " ", $charsets->{$File->{Use_Charset}}, 2;
    if ($command eq 'I') {
      eval {my $c = Text::Iconv->new($result_charset, 'utf-8')};
      $command = '' if ($@);
    }
    elsif ($command eq 'X') {
      $@ = "$File->{Use_Charset} undefined; replace by $result_charset";
    }
    if ($command ne 'I') {
      &print_table($File);
      &print_warnings($File);
      &print_charset_error($@, $File->{Use_Charset});
      &clean_up_and_exit($File);
    }
    my $c = Text::Iconv->new($result_charset, 'utf-8');
    my $line = 0;
    for (@{$File->{Content}}) {
      my $in = $_;
      $line++;
      $_ = $c->convert($_); # $_ is local!!
      push @lines, $line if ($in ne "" and $_ eq "");
    }
  }
  # check correctness of UTF-8 both for UTF-8 input and for conversion results
  unless ($File->{Use_Charset} eq 'unknown') {
    for (my $i = 0; $i < $#{$File->{Content}}; $i++) {
      # substitution needed for very long lines (>32K),
      # to avoid backtrack stack overflow
      local $_ = $File->{Content}->[$i];
      s/  [\x00-\x7F]                           # ASCII
        | [\xC2-\xDF]        [\x80-\xBF]        # non-overlong 2-byte sequences
        |  \xE0[\xA0-\xBF]   [\x80-\xBF]        # excluding overlongs
        | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}     # straight 3-byte sequences
        |  \xED[\x80-\x9F]   [\x80-\xBF]        # excluding surrogates
        |  \xF0[\x90-\xBF]   [\x80-\xBF]{2}     # planes 1-3
        | [\xF1-\xF3]        [\x80-\xBF]{3}     # planes 4-15
        |  \xF4[\x80-\x8F][\x80-\xBF]{2}        # plane 16
       //xg;
      push @lines, $i if length;
    }
  }
  if(@lines) {
    my $lines = $#lines ? "lines " : "line ";
    $lines .= join ", ", @lines;
    &print_table($File);
    &print_warnings($File);
    print <<"EOF";
    <p class="error">
      Sorry, I am unable to validate this document because on
      <strong>$lines</strong> it contained
      some byte(s) that I cannot interpret as
      <code>$File->{Use_Charset}</code>.
      Please check both the content of the file
      and the character encoding indication.
    </p>
EOF
    &clean_up_and_exit($File);
  }
}

my $xmlflags = '-wnon-sgml-char-ref';
my $catalog  = $sgmlstuff . '/catalog';

if ($File->{Type} eq 'xhtml') {
  $catalog               = $sgmlstuff . '/xhtml.soc';
  $ENV{SP_CHARSET_FIXED} = 'YES';
  $ENV{SP_ENCODING}      = 'UTF-8';
  $xmlflags              = '-wxml';
} elsif ($File->{Type} eq 'svg') {
  $catalog               = $sgmlstuff . '/svg.soc';
  $ENV{SP_CHARSET_FIXED} = 'YES';
  $ENV{SP_ENCODING}      = 'UTF-8';
  $xmlflags              = '-wxml';
} elsif ($File->{Type} eq 'smil') {
  $catalog               = $sgmlstuff . '/smil.soc';
  $ENV{SP_CHARSET_FIXED} = 'YES';
  $ENV{SP_ENCODING}      = 'UTF-8';
  $xmlflags              = '-wxml';
} elsif ($File->{Type} eq 'mathml') {
  $catalog               = $sgmlstuff . '/mathml.soc';
  $ENV{SP_CHARSET_FIXED} = 'NO';
  $ENV{SP_ENCODING}      = 'XML';
  $xmlflags              = '-wxml ';
} elsif ($File->{Type} eq 'xml' or $File->{Namespace}) {
  # no doctype, with xmlns attr on 1st element
  $File->{Type} = 'xml'; # @@ probably a better way to do this
  $catalog               = $sgmlstuff . '/sp-1.3/pubtext/xml.soc';
  $ENV{SP_CHARSET_FIXED} = 'YES';
  $ENV{SP_ENCODING}      = 'XML';
  $xmlflags              = '-wxml';
  $xmlflags             .= ' -wno-valid' unless $File->{DOCTYPE};
}

my $cmd = "$sp -c $catalog -E0 $xmlflags";
&add_table($File, "commandline", "<code>$cmd</code>") if $DEBUG;

#
# Temporary filehandles.
my $spin  = IO::File->new_tmpfile;
my $spout = IO::File->new_tmpfile;
my $sperr = IO::File->new_tmpfile;

#
# Dump file to a temp file for parsing.
for (@{$File->{Content}}) {
  print $spin $_, "\n";
}

#
# seek() to beginning of the file.
seek $spin, 0, 0;

#
# Run it through SP, redirecting output to temporary files.
my $pid = do {
  local(*SPIN, *SPOUT, *SPERR);
  (*SPIN, *SPOUT, *SPERR) = ($spin, $spout, $sperr);
  open3("<&SPIN", ">&SPOUT", ">&SPERR", $cmd);
};

#
# Close input file, reap the kid, and rewind temporary filehandles.
close $spin;
waitpid $pid, 0;
seek $_, 0, 0 for $spout, $sperr;

$File = &parse_errors($File, $sperr); # Parse error output.

$File->{ESIS} = [];
my $elements_found = 0;
while (<$spout>) {
  push @{$File->{'DEBUG'}->{ESIS}}, $_;
  $elements_found++ if /^\(/;

  if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml') {
    if (/^Axmlns() \w+ (.*)/ or /^Axmlns:([^ ]+) \w+ (.*)/) {
      if (not $File->{Namespace} and $elements_found == 0 and $1 eq "") {
	$File->{Namespace} = $2;
      }
      $File->{Namespaces}->{$2}++;
    }
  }
  next if / IMPLIED$/;
  next if /^ASDAFORM CDATA /;
  next if /^ASDAPREF CDATA /;
  chomp; # Removes trailing newlines
  push @{$File->{ESIS}}, $_;
}
undef $spout;


my $fpi;
$File->{Version} = 'unknown';
if ($File->{Type} eq 'xhtml' or $File->{Type} eq 'mathml' or $File->{Type} eq 'svg' or $File->{Type} eq 'smil') {
  $fpi = $File->{DOCTYPE};
} elsif ($File->{Type} eq 'xml') {
  $fpi = 'XML';
} else {
  for (@{$File->{ESIS}}) {
    next unless /^AVERSION CDATA (.*)/;
    $fpi = $1;
    last;
  }
  # Needed for HTML4 Strict, which has no version attribute on the HTML element
  if (length $File->{DOCTYPE} and not defined $fpi) {$fpi = $File->{DOCTYPE}};
}
$File->{Version} = $pub_ids->{$fpi} || 'unknown';

if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml') {
  &add_table($File, "Document Type", $File->{Version});
  if ($File->{Type} eq 'xhtml' and $File->{Namespace} ne 'http://www.w3.org/1999/xhtml') {
    &add_warning($File, "Unknown namespace (&#171;<code>$File->{Namespace}</code>&#187;) for text/html document!");
    if ($File->{Namespace} ne '') {
      &add_table($File, "Root Namespace",
	"<a href='$File->{Namespace}'>$File->{Namespace}</a>");
    }
  } elsif ($File->{Type} eq 'svg' and $File->{Namespace} ne 'http://www.w3.org/2000/svg') {
    &add_warning($File, "Unknown namespace (&#171;<code>$File->{Namespace}</code>&#187;) for SVG document!");
    if ($File->{Namespace} ne '') {
      &add_table($File, "Root Namespace",
	"<a href='$File->{Namespace}'>$File->{Namespace}</a>");
    }
  } else {
    if ($File->{Namespace} ne '') {
      &add_table($File, "Root Namespace",
	"<a href='$File->{Namespace}'>$File->{Namespace}</a>");
    }
  }

  if (scalar keys %{$File->{Namespaces}} > 1) {
    my $namespaces = "<ul>";
    for (keys %{$File->{Namespaces}}) {
      $namespaces .= "\t<li><a href='$_'>$_</a></li>\n"
          unless $_ eq $File->{Namespace}; # Don't repeat Root Namespace.
    }
    &add_table($File, "Other Namespaces", $namespaces . "</ul>");
  }
} else {
  &add_table($File, "Current Doctype", $File->{Version}); # is this current or detected???
}

unless ($File->{Opt}->{'Is Upload'}) { # @@@FIXME@@@: Temporarily Broken.
#  &add_table($File, qq(<label title="Select Doctype" for="doctype">Select Doctype</label>),
#	     $q->popup_menu(-name => 'doctype', -id => 'doctype',
#			    -values => [
#					'(detect automatically)',
#					'XHTML 1.0 Strict',
#					'XHTML 1.0 Transitional',
#					'XHTML 1.0 Frameset',
#					'HTML 4.01 Strict',
#					'HTML 4.01 Transitional',
#					'HTML 4.01 Frameset',
#					'HTML 3.2',
#					'HTML 2.0',
#				       ],
#			    -default => $File->{Opt}->{DOCTYPE},
#			   )
#	    );
}

&print_table($File);
&print_tip_of_the_day($File, $tips_db);
&print_warnings($File);

print "<h2>Validation Results</h2>\n";

if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml' or $File->{Type} eq 'mathml' or $File->{Type} eq 'svg' or $File->{Type} eq 'smil') {
  my $xmlvalid = ($File->{DOCTYPE} ? ' and validity' : '');
  print <<"EOHD";
  <p>
    Below are the results of checking this document for <a
    href="http://www.w3.org/TR/REC-xml#sec-conformance">XML
    well-formedness</a>$xmlvalid.
  </p>

EOHD
} else {
  print <<"EOHD";
  <p>
    Below are the results of attempting to parse this document with
    an SGML parser.
  </p>
EOHD
}

if (defined $File->{Tentative}) {
  my $class = '';
     $class .= ($File->{Tentative} & T_INFO  ? ' info'    :'');
     $class .= ($File->{Tentative} & T_WARN  ? ' warning' :'');
     $class .= ($File->{Tentative} & T_ERROR ? ' error'   :'');
     $class .= ($File->{Tentative} & T_FATAL ? ' fatal'   :'');

  unless ($File->{Tentative} == T_DEBUG) {
    print <<".EOF.";
    <p id="Notice" class="$class">
      Please note that you have chosen one or more options that alter the
      content of the document before validation, or have not provided enough
      information to accurately validate the document. Even if no errors are
      reported below, the document will not be valid until you manually make
      the changes we have performed automatically. Specifically, if you used
      some of the options that override a property of the document (e.g. the
      DOCTYPE or Character Encoding), you must make the same change to the
      source document or the server setup before it can be valid. You will
      also need to insert an appropriate DOCTYPE Declaration or Character
      Encoding (the "charset" parameter for the Content-Type HTTP header) if
      any of those are missing.
    </p>
.EOF.
  }
}

if (scalar @{$File->{Errors}}) {
  $File->{Opt}->{'Show Source'} = TRUE;
  &report_errors($File)
} else {
  &report_valid($File)
}

&weblint()          if $File->{Opt}->{'Weblint'};
&outline($File)     if $File->{Opt}->{'Outline'};
&show_source($File) if $File->{Opt}->{'Show Source'};
&parse_tree($File)  if $File->{Opt}->{'Show Parsetree'};
&show_esis($File)   if $File->{Opt}->{'Show ESIS'};
&show_errors($File) if $File->{Opt}->{'Show Errors'};

&clean_up_and_exit($File);


#############################################################################
# Subroutine definitions
#############################################################################

#
# Add info to the metadata table datastructure.
sub add_table {push @{shift->{Table}}, { Head => $_[0], Tail => $_[1]}};

#
# Print the table containing the metadata about the Document Entity.
sub print_table {
  my $File = shift;
  my $tableEntry;
  unless ($File->{Opt}->{URI} =~ m(^upload://)) {
    add_table($File, "Options",
	      '         <label title="Show Page Source"><input type="checkbox" value="" name="ss"' .
	      ($File->{Opt}->{'Show Source'}      ? 'checked="checked"' : '') . " />Show Source</label>\n" .
	      '         <label title="Show an Outline of the document"><input type="checkbox" value="" name="outline"' .
	      ($File->{Opt}->{'Outline'} ? 'checked="checked"' : '') . " />Outline</label>\n" .
	      '         <label title="Show Parse Tree"><input type="checkbox" value="" name="sp"' .
	      ($File->{Opt}->{'Show Parsetree'}      ? 'checked="checked"' : '') . " />Parse Tree</label>\n" .
	      '         <label title="Exclude Attributes from Parse Tree"><input type="checkbox" value="" name="noatt"' .
	      ($File->{Opt}->{'No Attributes'}   ? 'checked="checked"' : '') . " />...no attributes</label>\n"
	     );
  }
  print '  <form method="get" action="/check">'
    unless $File->{Opt}->{URI} =~ m(^upload://);
  print qq(<table class="header">\n);
  for $tableEntry (@{$File->{Table}}) {
    print "    <tr>\n";
    print ' ' x 6, "<th>", $$tableEntry{Head}, ": </th>\n";
    print ' ' x 6, "<td colspan='3'>", $$tableEntry{Tail}, "</td>\n";
    print "    </tr>\n";
  }
  print qq(    <tr><th><input type="submit" value="Revalidate" /></th><td>&nbsp;</td>\n)
    unless $File->{Opt}->{URI} =~ m(^upload://);
  print "  </table></form>\n";
}

#
# Add a waring message to the output.
sub add_warning {push @{shift->{Warnings}}, shift};

#
# Print out a list of warnings.
sub print_warnings {
  my $File = shift;
  return unless defined @{$File->{Warnings}};
  print qq(  <div id="skip"><h2>Notes &amp; Warnings</h2>\n  <ul>\n);
  print qq(    <li>$_</li>\n) for @{$File->{Warnings}};
  print "  </ul></div>\n";
}

#
# Print HTML explaining why/how to use a DOCTYPE Declaration.
sub output_doctype_spiel {
  print <<"EOF";
    <p>
      You should make the first line of your HTML document a DOCTYPE
      declaration, for example, for a typical <a
      href="http://www.w3.org/TR/html4/">HTML 4.01</a> document:
    </p>

    <pre>
      &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
      &lt;HTML&gt;
	&lt;HEAD&gt;
	  &lt;TITLE&gt;Title&lt;/TITLE&gt;
	&lt;/HEAD&gt;

	&lt;BODY&gt;
	  &lt;-- ... body of document ... --&gt;
	&lt;/BODY&gt;
      &lt;/HTML&gt;</pre>

EOF
}

#
# Spit out some closing HTML at the end of output.
sub output_closing {
  my $File = shift;
  print <<"EOF";
<address>
  <a href="$File->{Env}->{'Self URI'}/referer"><img
     src="http://www.w3.org/Icons/valid-html401" height="31" width="88"
     align=right border="0" alt="Valid HTML 4.01!"></a>
  <a href="/feedback.html">Gerald Oskoboiny</a><br>
  Last modified: $DATE
</address>

</body>

</html>
EOF
}


#
# Leave a message and then die (use for internal errors only)
sub internal_error {
  my $File = shift;
  my ($dieMessage) = shift;
  print <<"EOF";
    <hr>
    <strong class="error">Internal server error ($dieMessage).</strong>
    Please contact <a href="mailto:$MAINTAINER">maintainer</a>.
EOF
  &output_closing($File);
  die "$dieMessage\n";
}


#
# Clean up and exit... :-)
sub clean_up_and_exit {
  my $File = shift;
  &output_closing($File);
  exit;
}


#
# Generate HTML for the "Jump to:" links in results.
sub build_jump_links {
  my $File = shift;
  my $text  = '';
  my $count = 0;

  $count++ if $File->{Opt}->{'Show Source'};
  $count++ if $File->{Opt}->{'Show Parsetree'};
  $count++ if $File->{Opt}->{'Weblint'};
  $count++ if $File->{Opt}->{'Outline'};

  if ($count) {
    $text .= "  <p>\n    Jump to: ";
    if ($File->{Opt}->{'Weblint'}) {
      $text .= "<a\n      href=\"#weblint\">Weblint Results</a>";
      $count--;
      $text .= " or " if ( $count == 1 );
      $text .= ", "   if ( $count >  1 );
    }
    if ($File->{Opt}->{'Outline'}) {
      $text .= "<a\n      href=\"#outline\">Outline</a>";
      $count--;
      $text .= " or " if ( $count == 1 );
      $text .= ", "   if ( $count >  1 );
    }
    if ($File->{Opt}->{'Show Source'}) {
      $text .= "<a\n      href=\"#source\">Source Listing</a>";
      $count--;
      $text .= " or " if ( $count == 1 );
      $text .= ", "   if ( $count >  1 );
    }
    if ($File->{Opt}->{'Show Parsetree'}) {
      $text .= "<a\n      href=\"#parse\">Parse Tree</a>";
    }
    $text .= ".\n  </p>\n\n";
  }
  return $text;
}


#
# Proxy authentication requests.
sub authenticate {
  my $File       = shift;
  my $resource   = shift;
  my $authHeader = shift;
  my $realm = $resource;
  $realm =~ s([^\w\d.-]*){}g;
  $authHeader =~ s( realm=([\'\"])?([^\1]+)\1){ realm="$realm-$2"};

    print <<"EOF";
Status: 401 Authorization Required
WWW-Authenticate: $authHeader
Connection: close
Content-Type: text/html

<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">
<HTML><HEAD>
<TITLE>401 Authorization Required</TITLE>
</HEAD><BODY>
<H1>Authorization Required</H1>
<p>
  Sorry, I am not authorized to access the specified URI.
</p>

<p>
  The URI you specified,
</p>

<blockquote>
  <code><a href="$resource">$resource</a></code>
</blockquote>

<p>
  returned a 401 "authorization required" response when I tried
  to download it.
</p>

<p>
  You should have been prompted by your browser for a
  username/password pair; if you had supplied this information, I
  would have forwarded it to your server for authorization to
  access the resource. You can use your browser's "reload" function
  to try again, if you wish.
</p>

<p>
  Of course, you may not want to trust me with this information,
  which is fine. I can tell you that I don't log it or do
  anything else nasty with it, and you can <a
  href="$File->{Cfg}->{'Home Page'}source/">download the source for
  this service</a> to see what it does, but you have no guarantee
  that this is actually the code I'm using; you basically have to
  decide whether to trust me or not. :-)
</p>

<p>
  You should also be aware that the way we proxy this authentication
  information defeats the normal working of HTTP Authentication.
  If you authenticate to server A, your browser may keep sending
  the authentication information to us every time you validate
  a page, regardless of what server it's on, and we'll happily pass
  that on to the server thereby making it possible for a malicious
  server operator to capture your credentials.
</p>

<p>
  Due to the way HTTP Authentication works there is no way we can
  avoid this. We are using some "tricks" to fool your client into
  not sending this information in the first place, but there is no
  guarantee this will work. If security is a conern to you, you
  may wish to avoid validating protected resources or take extra
  precautions to prevent your browser from sending authentication
  information when validating other servers.
</p>

<p>
  Also note that you shouldn't use HTTP Basic Authentication for
  anything which really needs to be private, since the password
  goes across the network unencrypted.
</p>
EOF
}


#
# Complain about unknown HTTP responses.
sub print_unknown_http_error_message {
  my $uri = shift;
  my $code = shift;
  my $message = shift;

  print <<"EOF";
  <p>
    I got the following unexpected response when trying to
    retrieve <code><a href="$uri">$uri</a></code>:
  </p>

  <blockquote>
    <code>$code $message</code>
  </blockquote>

  <p>
    Please make sure you have entered the URI correctly.
  </p>

EOF
}


#
# Complain about strange charsets.
sub print_charset_error {
  my $error   = shift;
  my $charset = shift;

  print <<".EOF.";
  <p>Sorry!
    A fatal error occurred when attempting to transcode the character encoding
    of the document. Either we do not support this character encoding yet, or you 
    have specified a non-existent character encoding (often a misspelling).
  </p>
  <p>The detected character encoding was "$charset".</p>
  <p>The error was "$error".</p>
  <p>
    If you believe the character encoding to be valid you can submit a request for
    that character encoding (see the <a href="/feedback.html">feedback page</a>
    for details) and we will look into supporting it in the future.
  </p>
.EOF.
}


#
# Print blurb advocating using the CSS Validator.
sub output_css_validator_blurb {
  my $uri = shift;
  $uri = ent($uri);

  print <<"EOHD";
  <p>
    If you use <a href="http://www.w3.org/Style/CSS/">CSS</a> in your document,
    you should also <a
    href="http://jigsaw.w3.org/css-validator/validator?uri=$uri">check it for
    validity</a> using the W3C <a
    href="http://jigsaw.w3.org/css-validator/">CSS Validation Service</a>.
  </p>
EOHD
}


sub print_tip_of_the_day{
  my $File    = shift;
  my $tips_db = shift;
  my(%tips);
  open TIPS, $tips_db
    or &internal_error($File, "open($tips_db) returned $!");

  # quick-n-dirty XML parser...
  local($/) = '>';
  my(@stack, $line, $top, $name, $l, $addr, $slug);

  @stack = ();
  $line = 1;
  $slug = '';

  while(<TIPS>){
    if(m,/>$,){ # empty element
      $slug .= $_ if $slug;
    }
    elsif(m,</(\w+),){
      my($content, $tag);
      $content = $`;
      $tag = $& . $';
      $slug .= $content if $slug;

      $name = $1;
      $top = pop(@stack);
      $l = pop(@stack);
      if($name ne $top){
	print STDERR "@stack \n";
	die "found /$name expecting /$top $l";
      }

      if($name eq 'a'){
	$tips{$addr} = $slug;
	$slug = '';
      }

      $slug .= $tag if $slug;

    }
    elsif(m,<(\w+),){
      $slug .= $_ if $slug;

      $name = $1;
      push(@stack, $line);
      push(@stack, $name);
      if($name eq 'a'){
	if(m,href=\"([^\"]+)\",){
	  $addr = $1;
	  $slug = ' ';
	}
      }
    }
    
    while(s/\n//){
      $line++;
    }
  }

  my @tipAddrs = keys %tips;
  my $tipQty = $#tipAddrs + 1;
  srand(time());
  my $whichTip = rand($tipQty);
  my $tipAddr = $tipAddrs[$whichTip];
  my $tipSlug = $tips{$tipAddr};

  print <<"EOHD";
  <div class="tip" align="center" style="text-align: center; background-color: yellow">
    <strong><a href="http://www.w3.org/2001/06tips/">TIP</a>:</strong>
    <a href="$tipAddr">$tipSlug</a>
  </div>
EOHD
}


#
# Read TAB-delimited configuration files. Returns a hash reference.
sub read_cfg {
  my $file = shift;
  my %cfg;

  open CFG, $file or die "open($file) returned: $!\n";
  while (<CFG>) {
    next if /^\s*$/;
    next if /^\s*#/;
    chomp;
    my($k, $v) = split /\t+/, $_;
    $cfg{$k} = $v;
  }
  close CFG;
  return \%cfg;
}

#
# Fetch an URI and return the content and selected meta-info.
sub handle_uri {
  my $q    = shift; # The CGI object.
  my $File = shift; # The master datastructure.

  my $uri = $q->param('uri'); # The URI to fetch.

  my $ua = new LWP::UserAgent;
  $ua->agent("W3C_Validator/$VERSION " . $ua->agent);
  $ua->parse_head(0);  # Parse the http-equiv stuff ourselves. @@ Why?
  my $req = new HTTP::Request(GET => $uri);

  # If we got a Authorization header, the client is back at it after being
  # prompted for a password so we insert the header as is in the request.
  if($ENV{HTTP_AUTHORIZATION}){
    $req->headers->header(Authorization => $ENV{HTTP_AUTHORIZATION});
  }

  my $res = $ua->request($req);

  unless ($res->code == 200) {
    if ($res->code == 401) {
      &authenticate($File, $res->request->url, $res->www_authenticate);
    } else {
      print $File->{Results};
      &print_unknown_http_error_message($uri, $res->code, $res->message);
    }
    &clean_up_and_exit($File);
  }

  my($type, $charset) = &parse_content_type($res->header('Content-Type'));

  my $lastmod = undef;
  if ( $res->last_modified ) {
    $lastmod = scalar(gmtime($res->last_modified));
  }

  $File->{Content}      = &normalize_newlines($res->content);
  $File->{Type}         = $type;
  $File->{HTTP_Charset} = $charset;
  $File->{Modified}     = $lastmod;
  $File->{Server}       = scalar($res->server);
  $File->{Size}         = scalar($res->content_length);
  $File->{Opt}->{URI}          = scalar($res->request->url);

  return $File;

}

#
# Handle uploaded file and return the content and selected meta-info.
sub handle_file {
  my $q    = shift; # The CGI object.
  my $File = shift; # The master datastructure.

  my $f = $q->param('uploaded_file');
  my $h = $q->uploadInfo($f);
  my $file;

  while (not eof $f) {$file .= <$f>};
  my($type, $charset) = &parse_content_type($h->{'Content-Type'});

  $File->{Content}      = &normalize_newlines($file);
  $File->{Type}         = $type;
  $File->{HTTP_Charset} = $charset;
  $File->{Modified}     = $h->{'Last-Modified'};
  $File->{Server}       = $h->{'Server'};
  $File->{Size}         = $h->{'Content-Length'};
  $File->{Opt}->{URI}          = $q->param('uploaded_file');

  return $File;
}

#
# Handle uploaded file and return the content and selected meta-info.
sub handle_frag {
  my $q    = shift; # The CGI object.
  my $File = shift; # The master datastructure.

  $File->{Content}      = &normalize_newlines(shift->param('fragment'));
  $File->{Type}         = 'html';
  $File->{HTTP_Charset} = '';
  $File->{Modified}     = '';
  $File->{Server}       = '';
  $File->{Size}         = '';
  $File->{Opt}->{URI}          = 'upload://Form Submission';

  return $File;
}


#
# Parse a Content-Type and parameters. Return document type and charset.
sub parse_content_type {
  my $Content_Type = shift;
  my $charset      = '';
  my $type         = '';

  my($ct, @param) = split /\s*;\s*/, lc $Content_Type;

  $type = $file_type->{$ct} || $ct;

  foreach my $param (@param) {
    my($p, $v) = split /\s*=\s*/, $param;
    next unless $p =~ m(charset)i;
    if ($v =~ m/([\'\"]?)(\S+)\1/i) {
      $charset = lc $2;
      last;
    }
  }

  return $type, $charset;
}


#
# Normalize newline forms (CRLF/CR/LF) to native newline.
sub normalize_newlines {
  my $file = shift;

  $file =~ s(\015\012?|\012){\n}g; # Turn ASCII CRLF into native newline.

  return [split /\n/, $file];
}


#
# Return $_[0] encoded for HTML entities (cribbed from merlyn).
sub ent {
  local $_ = shift;
  s(["<&>"]){'&#' . ord($&) . ';'}ge;
  return $_;
}


#
# Truncate source lines for report.
sub truncate_line {
  my $line = shift;
  my $col  = shift;

  if (length $line > 70) {
    if ($col < 25) {      # Truncate at 70 chars and right side only.
      $line = substr($line, 0, 70) . " ...";
    } elsif ($col > 70) { # Keep rightmost 70 chars; left side only.
      my $diff = $col - 50;
      $line = "... " . substr($line, $diff, 70);
      if (length $line == 70 + 4) {
	$line .= " ...";
      }
      if ($col > $diff) {
	$col -= $diff;
      } else {
	$col -= 70;
      }
    } else { # Truncate both sides; leave more on left, and 30 chars on right.
      if ($col < 35) {
	$line = "... " . substr($line, 0, 60);
      } else {
	$line = "... " . substr($line, $col - 35, 60);
	$col = 35;
      }
      if (length $line == 60 + 4) {$line .= " ..."};
    }
  }

  return $line, $col;
}


#
# Supress any existing DOCTYPE by commenting it out.
sub supress_doctype {
  no strict 'vars';
  my $file = shift;
  local $HTML = '';

  HTML::Parser->new(default_h     => [sub {$HTML .= shift}, 'text'],
		    declaration_h => [sub {$HTML .= '<!-- ' . $_[0] . ' -->'}, 'text']
		   )->parse(join "\n", @{$file});
  return [split /\n/, $HTML];
}


#
# Parse errors reported by SP.
sub parse_errors ($$) {
  my $File = shift;
  my $fh   = shift;

  $File->{Errors} = []; # Initialize to an (empty) anonymous array ref.

  for (<$fh>) {
    push @{$File->{'DEBUG'}->{Errors}}, $_;
    my($err, @errors);
    next if /^<OSFD>0:[0-9]+:[0-9]+:[^A-Z]/;
    next if /numbers exceeding 65535 not supported/;
    next if /URL Redirected to/;

    my(@_err) = split /:/;
    next unless $_err[1] eq '<OSFD>0';
    if ($_err[1] =~ m(^<URL>)) {
      @errors = ($_err[0], join(':', $_err[1], $_err[2]), @_err[3..$#_err]);
    } else {
      @errors = @_err;
    }
    $err->{src}  = $errors[1];
    $err->{line} = $errors[2];
    $err->{char} = $errors[3];
    $err->{type} = $errors[4];
    if (
	   $err->{type} eq 'W'
	or $err->{type} eq 'E'
	or $err->{type} eq 'X'
	or $err->{type} eq 'Q'
       ) {
      $err->{msg}  = $errors[5];
      # get rid of non-BMP related error messages
      # (pretending SP understands characters beyond the BMP)
      if ($errors[5] =~ m/"(\d*)" is not a character number in the document character set/) {
	next if $1 >= 65536 && $1 <= 1114110;
      }
    } else {
      $err->{type} = 'I';
      $err->{msg}  = $errors[4];
    }
    push @{$File->{Errors}}, $err;
  }
  undef $fh;
  return $File;
}

#
# Generate a HTML report of detected errors.
sub report_errors ($) {
  print '<ul>';
  my $File = shift;
  foreach my $err (@{$File->{Errors}}) {

    # An unknown FPI and no SI.
    if (   $err->{msg} =~ m(cannot generate system identifier for entity)
	or $err->{msg} =~ m(unrecognized ({{)?DOCTYPE(}})?)i
        or $err->{msg} =~ m(no document type declaration)i) {
      print <<"    .EOF.";
    <p><strong>Fatal Error</strong>: $err->{msg}</p>
    <p>
      I could not parse this document, because it uses a public identifier that
      is not in my <a href="/sgml-lib/catalog">catalog</a>.
    </p>
    .EOF.
      &output_doctype_spiel;
      last;
    }

    # No or unknown FPI and a relative SI.
    if ($err->{msg} =~ m(cannot (open|find))) {
      print <<"    .EOF.";
    <p><strong>Fatal Error: $err->{msg}</p>
    <p>
      I could not parse this document, because it makes reference to a
      system-specific file instead of using a well-known public identifier to
      specify the type of markup being used.
    </p>
    .EOF.
      &output_doctype_spiel;
      last;
    }

    my($line, $col) = &truncate_line($File->{Content}->[$err->{line}-1], $err->{char});

    # Strip curlies from lq-nsgmls output.
    $err->{msg} =~ s/[{}]//g;

    # Find index into the %frag hash for the "explanation..." links.
    $err->{idx} =  $err->{msg};
    $err->{idx} =~ s/"[^\"]*"/FOO/g;
    $err->{idx} =~ s/[^A-Za-z ]//g;
    $err->{idx} =~ s/\s+/ /g; # Collapse spaces
    $err->{idx} =~ s/(^\s|\s$)//g; # Remove leading and trailing spaces.
    $err->{idx} =~ s/(FOO )+/FOO /g; # Collapse FOOs. :-)
    $err->{idx} =~ s/FOO FOO/FOO/g; # Collapse FOOs. :-)

    $line = &ent($line); # Entity encode.
    $line =~ s/\t/ /g;   # Collapse TABs.

    print qq(  <li><em>Line <a href="#line-$err->{line}">$err->{line}</a>, column $col</em>: );
    print qq{<span class="msg">$err->{msg}</span>};

    if (defined $frag->{$err->{idx}}) {
      print qq{ (<a href="$File->{Cfg}->{'Msg FAQ URI'}#$frag->{$err->{idx}}">explanation...</a>)};
    } elsif (DEBUG) {
      print qq{ (<code style="background: red">"$err->{idx}"</code>)};
    }

    print "\n<pre>  <code class=input>$line</code>\n";
    print " " x ($col + 2); # 2 is the number of spaces before <code> above
    print " " x 4 if $col != $err->{char}; # only for truncated lines
    print "<span class=markup>^</span></pre>\n";
  }
  print "</ul>\n";
  print "<hr>\n";
  if ($File->{Version} eq 'unknown') {
    print "<p>Sorry, I can't validate this document.</p>";
  } elsif ($File->{Type} eq 'xml') {
    print "<p>Sorry, this document is not well-formed XML.</p>";
  } else {
    print "<p>Sorry, this document does not validate as $File->{Version}.</p>";
    &output_css_validator_blurb($File->{Opt}->{URI});
  }
}


#
# Output "This page is Valid" report.
sub report_valid {
  my $File = shift;
  my $gifborder   = ' border="0"';
  my $xhtmlendtag = '';
  my($image_uri, $alttext, $gifhw);

  if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml') {
    print "\n  <pre>\n    No errors found! ";
    print '<a title="Caveat" href="#sp-lim">*</a></pre>', "\n\n";
  } else {
    print "\n  <pre>\n    No errors found!</pre>\n\n";
  }

  unless ($File->{Version} eq 'unknown' or defined $File->{Tentative}) {
    if ($File->{Version} =~ /^HTML 2\.0$/) {
      $image_uri = "$File->{Cfg}->{'Home Page'}images/vh20";
      $alttext = "Valid HTML 2.0!";
      $gifborder = "";
    } elsif ($File->{Version} =~ /HTML 3\.2</) {
      $image_uri = "http://www.w3.org/Icons/valid-html32";
      $alttext = "Valid HTML 3.2!";
      $gifhw   = ' height="31" width="88"';
    } elsif ($File->{Version} =~ /HTML 4\.0<\/a> Strict$/) {
      $image_uri = "http://www.w3.org/Icons/valid-html40";
      $alttext = "Valid HTML 4.0!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
    } elsif ($File->{Version} =~ /HTML 4\.0<\/a> /) {
      $image_uri = "http://www.w3.org/Icons/valid-html40";
      $alttext = "Valid HTML 4.0!";
      $gifhw   = ' height="31" width="88"';
    } elsif ($File->{Version} =~ /HTML 4\.01<\/a> Strict$/) {
      $image_uri = "http://www.w3.org/Icons/valid-html401";
      $alttext = "Valid HTML 4.01!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
    } elsif ($File->{Version} =~ /HTML 4\.01<\/a> /) {
      $image_uri = "http://www.w3.org/Icons/valid-html401";
      $alttext = "Valid HTML 4.01!";
      $gifhw   = ' height="31" width="88"';
    } elsif ($File->{Version} =~ /XHTML 1\.0<\/a> /) {
      $image_uri = "http://www.w3.org/Icons/valid-xhtml10";
      $alttext = "Valid XHTML 1.0!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
      $xhtmlendtag = " /";
#    } elsif ($File->{Version} =~ /XHTML Basic 1.0/) {
#      $image_uri = "$File->{Cfg}->{'Home Page'}/images/vxhtml-basic10";
#      $alttext = "Valid XHTML Basic 1.0!";
#      $gifborder = "";
#      $gifhw   = ' height="31" width="88"';
#      $xhtmlendtag = " /";
    } elsif ($File->{Version} =~ /XHTML 1.1/) {
      $image_uri = "http://www.w3.org/Icons/valid-xhtml11";
      $alttext = "Valid XHTML 1.1!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
      $xhtmlendtag = " /";
    } elsif ($File->{Version} =~ /HTML 3\.0/) {
      $image_uri = "$File->{Cfg}->{'Home Page'}images/vh30";
      $alttext = "Valid HTML 3.0!";
    } elsif ($File->{Version} =~ /Netscape/) {
      $image_uri = "$File->{Cfg}->{'Home Page'}images/vhns";
      $alttext = "Valid Netscape-HTML!";
    } elsif ($File->{Version} =~ /Hotjava/) {
      $image_uri = "$File->{Cfg}->{'Home Page'}images/vhhj";
      $alttext = "Valid Hotjava-HTML!";
    }

    if (defined $image_uri) {
      print <<"EOHD";
  <p>
    <img src="$image_uri" alt="$alttext"> Congratulations, this
    document validates as $File->{Version}!
  </p>

  <p>
    To show your readers that you have taken the care to create an
    interoperable Web page, you may display this icon on any page
    that validates. Here is the HTML you could use to add this icon
    to your Web page:
  </p>
  <pre>
  &lt;p&gt;
    &lt;a href="$File->{Cfg}->{'Home Page'}check/referer"&gt;&lt;img$gifborder
        src="$image_uri"
        alt="$alttext"$gifhw$xhtmlendtag&gt;&lt;/a&gt;
  &lt;/p&gt;</pre>
  <p>
    If you like, you can download a copy of this image (in <a
    href="${image_uri}.png">PNG</a> or <a href="${image_uri}.gif">GIF</a>
    format) to keep in your local web directory, and change the HTML fragment
    above to reference your local image rather than the one on this server.
  </p>

EOHD
    }
  }
  if ($File->{Type} eq 'xml' and not $File->{DOCTYPE}) {
    print "  <p>Congratulations, this document is well-formed XML.</p>\n";
  } elsif (defined $File->{Tentative}) {
    if ($File->{Tentative} == T_CHARSET_KLUDGE) {
      print "  <p>\n    This document would validate as the document type specified if you updated it to specify the Character Encoding used.\n  </p>\n";
    } else {
      print "  <p>\n    This document would validate as the document type specified if you updated it to match the Options used.\n  </p>\n";
    }
  } elsif ($File->{Version} eq 'unknown' or not defined $image_uri) {
    print "  <p>\n    Congratulations, this document validates as the document type specified! (I don't have an icon for this one yet, sorry.)\n  </p>\n";
  }

  unless ($File->{Opt}->{URI} =~ m(upload://)) {
    my $thispage = $File->{Env}->{'Self URI'};
    $thispage .= qq(?uri=$File->{Opt}->{URI});
    $thispage .= ';ss=1'      if $File->{Opt}->{'Show Source'};
    $thispage .= ';sp=1'      if $File->{Opt}->{'Show Parsetree'};
    $thispage .= ';noatt=1'   if $File->{Opt}->{'No Attributes'};
    $thispage .= ';outline=1' if $File->{Opt}->{'Outline'};

    &output_css_validator_blurb($File->{Opt}->{URI});

    print <<"EOHD";
  <p>
    If you would like to create a link to <em>this</em> page (i.e., this
    validation result) to make it easier to re-validate this page in the
    future or to allow others to validate your page, the URI is:
  </p>

  <blockquote>
    <code><a href="$thispage">$thispage</a></code>
  </blockquote>

  <p>
    (Or, you can just add the current page to your bookmarks or hotlist.)
  </p>
EOHD
  }
  if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml') {
    print qq{    <h2><a name="sp-lim">Caveat</a></h2>
      <p>
	This validator is based on SP, which has <a
	href="http://www.jclark.com/sp/xml.htm">some limitations
	in its support for XML</a>.
      </p>
	    };
  }
}


#
# Produce an outline of the document based on Hn elements from the ESIS.
sub outline {
  my $File = shift;

  print <<'EOF';
  <div id="outline" class="mtb">
    <hr>
    <h2><a name="outline">Outline</a></h2>
    <p>
      Below is an outline for this document, automatically generated from the
      heading tags (<code>&lt;H1&gt;</code> through <code>&lt;H6&gt;</code>.)
    </p>
EOF

  my $prevlevel = 0;
  my $indent    = 0;
  my $level     = 0;

  for (1 .. $#{$File->{ESIS}}) {
    my $line = $File->{ESIS}->[$_];
    next unless $line =~ /^\(H([1-6])$/i;
    $prevlevel = $level;
    $level     = $1;

    print "    </ul>\n" x ($prevlevel - $level); # perl is so cool.
    if ($level - $prevlevel == 1) {print "    <ul>\n"};
    foreach my $i (($prevlevel + 1) .. ($level - 1)) {
      print qq(  <ul>\n    <li class="warning">A level $i heading is missing!\n);
    }
    if ($level - $prevlevel > 1) {print "    <ul>\n"};

    $line       = '';
    my $heading = '';
    until (substr($line, 0, 3) =~ /^\)H$level/i) {
      $line = $File->{ESIS}->[$_++];
      $line =~ s/\\011/ /g;
      $line =~ s/\\012/ /g;
      if ($line =~ /^-/) {
	my $headcont = $line;
	substr($headcont, 0, 1) = " ";
	$headcont =~ s/\\n/ /g;
	$heading .= $headcont;
      } elsif ($line =~ /^AALT CDATA( .+)/i) {
	my $headcont = $1;
	$headcont =~ s/\\n/ /g;
	$heading .= $headcont;
      }
    }

    $heading = substr($heading, 1); # chop the leading '-' or ' '.
    $heading = &ent($heading);
    print "    <li>$heading\n";
  }
  print "    </ul>\n" x $level;
  print <<'EOF';
    <p>
      If this does not look like a real outline, it is likely that the
      heading tags are not being used properly. (Headings should reflect
      the logical structure of the document; they should not be used simply
      to add emphasis, or to change the font size.)
    </p>
    </div>
EOF
}


#
# Create a HTML representation of the document.
sub show_source {
  my $File = shift;
  my $line = 1;

  print <<'EOF';
  <div id="source" class="mtb">
    <hr>
    <h2><a name="source">Source Listing</a></h2>

    <p>Below is the source input I used for this validation:</p>
    <pre>
EOF

  for (@{$File->{Content}}) {
    printf "<a name=\"line-%s\">%4d</a>: %s\n", $line, $line, ent $_;
    $line++;
  }
  print "    </pre>\n  </div>";
}


#
# Create a HTML Parse Tree of the document for validation report.
sub parse_tree {
  my $File = shift;

  print <<'EOF';
  <div id="parse" class="mtb">
    <hr>
    <h2><a name="parse">Parse Tree</a></h2>
EOF
  if ($File->{Opt}->{'No Attributes'}) {
    print <<'EOF';
    <p class="note">
      I am excluding the attributes, as you requested.
    </p>
EOF
  } else {
    print <<'EOF';
    <p class="note">
      You can also view this parse tree without attributes by selecting the
      appropriate option on <a href="./#byURI">the form</a>.
    </p>
EOF
  }

  my $indent   = 0;
  my $prevdata = '';

  print "<pre>\n";
  foreach my $line (@{$File->{ESIS}}) {
    if ($File->{Opt}->{'No Attributes'}) { # don't show attributes
      next if $line =~ /^A/;
      next if $line =~ /^\(A$/;
      next if $line =~ /^\)A$/;
    }

    $line =~ s/\\n/ /g;
    $line =~ s/\\011/ /g;
    $line =~ s/\\012/ /g;
    $line =~ s/\s+/ /g;
    next if $line =~ /^-\s*$/;

    if ($line =~ /^-/) {
      substr($line, 0, 1) = ' ';
      $prevdata .= $line;
      next;
    } elsif ($prevdata) {
      $prevdata = &ent($prevdata);
      $prevdata =~ s/\s+/ /go;
      print wrap(' ' x $indent, ' ' x $indent, $prevdata), "\n";
      undef $prevdata;
    }

    $line = &ent($line);
    if ($line =~ /^\)/) {
      $indent -= 2;
    }

    my $printme;
    chomp($printme = $line);
    $printme =~ s{^([()])(.*)}	# reformat and add links on HTML elements
		 { my $close = '';
		      $close = "/" if $1 eq ")";	# ")" -> close-tag
		   "&lt;" . $close . "<a href=\"" .
		   $File->{Cfg}->{'Element Ref URI'} . $element_uri->{lc($2)} .
		   "\">$2<\/a>&gt;"
		 }egx;
    $printme =~ s,^A,  A,;	# indent attributes a bit
    print ' ' x $indent, $printme, "\n";
    if ($line =~ /^\(/) {
      $indent += 2;
    }
  }
  print "</pre>\n";
  print "</div>\n";
}


#
# Do an initial parse of the Document Entity to extract charset and FPI.
sub preparse {
  my $File = shift;

  my $dtd = sub {
    return if $File->{Root};
    ($File->{Root}, $File->{DOCTYPE}) = shift =~  m(<!DOCTYPE\s+(\w+)\s+PUBLIC\s+(?:[\'\"])([^\"\']+)(?:[\"\']).*>)si;
  };
  my $pi = sub {
    return if $File->{XML_Charset};
    my $pi = shift;
    return unless $pi =~ m(<\?xml);
    $pi =~ m(<\?xml[^>]*\sencoding\s*=\s*([\"\'])([A-Za-z][-A-Za-z0-9._]*)\1)s;
    warn qq("$1" - "$2"\n);
    $File->{XML_Charset} = lc $2;
  };
  my $start = sub {
    my $tag  = shift;
    my $attr = shift;
    my %attr = map {lc($_) => $attr->{$_}} keys %{$attr};

    if ($File->{Root}) {
      if (lc $tag eq 'meta') {
	if (lc $attr{'http-equiv'} eq 'content-type') {
	  if ($attr{content} =~ m(charset\s*=[\s\"\']*([^\s;\"\'>]*))si) {
	    $File->{META_Charset} = lc $1;
          }
	}
      }
      return unless $tag eq $File->{Root};
    } else {
      $File->{Root} = $tag;
    }
    if ($attr->{xmlns}) {$File->{Namespace} = $attr->{xmlns}};
  };

  my $p =  HTML::Parser->new(api_version => 3);
  $p->xml_mode(TRUE);
  $p->ignore_elements('BODY');
  $p->ignore_elements('body');
  $p->handler(declaration => $dtd, 'text');
  $p->handler(process => $pi, 'text');
  $p->handler(start => $start, 'tag,attr');
  $p->parse(join "\n", @{$File->{Content}});

  return $File;
}

#
# Print out the raw ESIS output for debugging.
sub show_esis ($) {
  print <<'EOF';
  <div id="raw_esis" class="mtb">
    <hr>
    <h2><a name="raw_esis">Raw ESIS Output</a></h2>
    <pre>
EOF
  for (@{shift->{'DEBUG'}->{ESIS}}) {
    s/\\012//g;
    s/\\n/\n/g;
    print ent $_;
  }
  print "    </pre>\n  </div>";
}

#
# Print out the raw error output for debugging.
sub show_errors ($) {
  print <<'EOF';
  <div id="raw_errors" class="mtb">
    <hr>
    <h2><a name="raw_errors">Raw Error Output</a></h2>
    <pre>
EOF
  for (@{shift->{'DEBUG'}->{Errors}}) {print ent $_};
  print "    </pre>\n  </div>";
}


#
# Preprocess CGI parameters.
sub prepCGI {
  my $File = shift;
  my    $q = shift;

  # Avoid CGI.pm's "exists but undef" behaviour.
  if (scalar $q->param) {
    foreach my $param ($q->param) {
      next if $param eq 'uploaded_file'; # 'uploaded_file' contains data.
      $q->param($param, TRUE) unless $q->param($param);
    }
  }

  # Futz the URI so "/referer" works.
  $q->param('uri', $q->referer) if $q->path_info eq '/referer';

  # USe HTTP Referer if uri=referer.
  $q->param('uri', $q->referer) if $q->param('uri') =~ m(referer)i;

  # Use "url" unless a "uri" was also given.
  $q->param('uri', $q->param('url')) if $q->param('url') and not $q->param('uri');

  # Supercede URI with an uploaded file.
  if ($q->param('uploaded_file')) {
    $q->param('uri', 'upload://' . $q->param('uploaded_file'));
    $File->{Opt}->{'Is Upload'} = TRUE; # Tag it for later use.
  }

  # Supercede URI with an uploaded fragment.
  if ($q->param('fragment')) {$q->param('uri', 'upload://Form Submission')};

  # Munge the URI to include commonly omitted prefix.
  $q->param('uri', 'http://' . $q->param('uri')) if $q->param('uri') =~ m(^www)i;

  return $q;
}
